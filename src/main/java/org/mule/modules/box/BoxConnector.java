/**
 * Copyright (c) MuleSoft, Inc. All rights reserved. http://www.mulesoft.com
 *
 * The software in this package is published under the terms of the CPAL v1.0
 * license, a copy of which has been included with this distribution in the
 * LICENSE.md file.
 */

/**
 * This file was automatically generated by the Mule Development Kit
 */
package org.mule.modules.box;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Formatter;

import javax.inject.Inject;
import javax.ws.rs.core.MediaType;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.mule.DefaultMuleMessage;
import org.mule.api.MuleContext;
import org.mule.api.MuleException;
import org.mule.api.MuleMessage;
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Connector;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.lifecycle.Start;
import org.mule.api.annotations.lifecycle.Stop;
import org.mule.api.annotations.param.Default;
import org.mule.api.annotations.param.Optional;
import org.mule.api.context.MuleContextAware;
import org.mule.construct.Flow;
import org.mule.modules.box.model.Folder;
import org.mule.modules.box.model.FolderItems;
import org.mule.modules.box.model.User;
import org.mule.modules.box.model.request.CreateFolderRequest;
import org.mule.modules.box.model.response.GetAuthTokenResponse;
import org.mule.modules.box.model.response.GetTicketResponse;
import org.mule.modules.box.model.response.UploadFileResponse;
import org.mule.modules.boxnet.callback.AuthCallbackAdapter;

import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.WebResource;
import com.sun.jersey.api.client.config.ClientConfig;
import com.sun.jersey.api.client.config.DefaultClientConfig;
import com.sun.jersey.api.json.JSONConfiguration;
import com.sun.jersey.core.impl.provider.entity.FormMultivaluedMapProvider;
import com.sun.jersey.core.impl.provider.entity.FormProvider;
import com.sun.jersey.core.impl.provider.entity.InputStreamProvider;
import com.sun.jersey.core.impl.provider.entity.MimeMultipartProvider;
import com.sun.jersey.multipart.FormDataMultiPart;
import com.sun.jersey.multipart.file.StreamDataBodyPart;
import com.sun.jersey.multipart.impl.MultiPartWriter;

/**
 * Box Cloud Connector for API V2.
 * 
 * @author mariano.gonzalez@mulesoft.com
 */
@Connector(name="box", schemaVersion="2.0", friendlyName="Box", minMuleVersion="3.3")
public class BoxConnector implements MuleContextAware {
    
	private static final Logger logger = Logger.getLogger(BoxConnector.class);
	
	private static final String BOX_AUTH_TICKET = "boxAuthTicket";
	private static final String BOX_AUTH_TOKEN = "boxAuthToken";
	private static final String BASE_URL = "https://api.box.com/2.0/";
	
	/**
	 * The url where the user needs to enter his credentials
	 */
	private static final String AUTH_URL = "https://www.box.com/api/1.0/rest"; 
	
	
	private Client client;
	
	private MuleContext muleContext;
	private AuthCallbackAdapter authCallback;
	
    /**
     * The API key obtained when registering a project with the Box platform.
     * For more information about this field please refer to {@link http://developers.box.net/}
     */
    @Configurable
    private String apiKey;
    
    /**
     * If true, an http inbound endpoint will be set in place to receive a callback
     * from box.net with the authToken once the user has authenticated.
     * 
     * If this callback is in place, there's no need for you to manually
     * invoke the get-auth-token processor.
     * 
     * For more info look at http://developers.box.net/w/page/12923915/ApiAuthentication
     * 
     * Defaults to false
     */
    @Optional
    @Configurable
    @Default("false")
    private boolean usesCallback = false;
    
    
    /**
     * The url where box.net will direct the authentication callback.
     * For more info look at http://developers.box.net/w/page/12923915/ApiAuthentication
     * 
     * Defaults to box_auth_callback
     */
    @Optional
    @Configurable
    @Default("box_auth_callback")
    private String callbackPath = "box_auth_callback";
   
    /**
     * The port where the authentication callback will be listening on
     * Defaults to 8080
     */
    @Optional
    @Configurable
    @Default("8080")
    private Integer callbackPort;
    
    /**
     * The name of a flow to be executed each time the authentication token
     * needs to be used. If this attribute is specified, 	then a flow with this named
     * will be fetch on the registry and invoked every time the auth token is needed.
     * This flow will receive a copy of the current mule message and must set the payload
     * to a valid auth token. If the flow fails to accomplish that, an exception will be thrown
     * 
     * For example:
     * 
     * &lt;box:config apiKey="${apiKey}" restoreAuthTokenFlow="restoreTokenFlow" saveAuthTokenFlow="saveTokenFlow"/&gt;
     * 
     *  &lt;flow name="restoreTokenFlow"&gt;
     *		&lt;objectstore:retrieve key="flowVars['currentUserId']"/&gt;
     *	&lt;/flow&gt;
     *
     *	&lt;flow name="save"&gt;
     *		&lt;objectstore:store key="flowVars['currentUserId']" value-ref="#[flowVars['boxAuthToken']]"/&gt;
     *	&lt;/flow&gt;
     *
     *	If this attribute is not specified, then the token will be fetched from memory. Notice that this means the token won't survive
     * an application restart and that the connector would be incapable of handling two different concurrent accounts
     */
    @Configurable
    @Optional
    private String restoreAuthTokenFlow;
    
    /**
     * The name of a flow to be executed each time an authentication token
     * is received. If this attribute is specified, then a flow with this name
     * will be fetch on the registry and invoked every time the auth token is obtained.
     * This flow will receive a copy of the current mule message carrying two additional invocation variables:
     * 
     * <ul>
     * 	<li>boxAuthTicket: The ticket for which the authorization token was generated</li>
     * 	<li>boxAuthToken: The obtained authorization token
     * </ul>
     * 
     * For example:
     * 
     * &lt;box:config apiKey="${apiKey}" restoreAuthTokenFlow="restoreTokenFlow" saveAuthTokenFlow="saveTokenFlow"/&gt;
     * 
     *  &lt;flow name="restoreTokenFlow"&gt;
     *		&lt;objectstore:retrieve key="flowVars['currentUserId']"/&gt;
     *	&lt;/flow&gt;
     *
     *	&lt;flow name="save"&gt;
     *		&lt;objectstore:store key="flowVars['currentUserId']" value-ref="#[flowVars['boxAuthToken']]"/&gt;
     *	&lt;/flow&gt;
     *
     * If this attribute is not specified, then the token will be stored in memory. Notice that this means the token won't survive
     * an application restart and that the connector would be incapable of handling two different concurrent accounts
     */
    @Configurable
    @Optional
    private String saveAuthTokenFlow;
    
    /**
     * The name of a flow to be invoked after an authorization callback is received.
     * If {@link usesCallback} is false then this flow will never be invoked.
     * 
     * This flow will receive a copy of the current mule message carrying two additional invocation variables:
     * 
     * <ul>
     * 	<li>boxAuthTicket: The ticket for which the authorization token was generated</li>
     * 	<li>boxAuthToken: The obtained authorization token
     * </ul>
     * 
     * For example:
     * 
     * &lt;box:config apiKey="${apiKey}" restoreAuthTokenFlow="restoreTokenFlow" saveAuthTokenFlow="saveTokenFlow"/&gt;
     * 
     *  &lt;flow name="restoreTokenFlow"&gt;
     *		&lt;objectstore:retrieve key="flowVars['currentUserId']"/&gt;
     *	&lt;/flow&gt;
     *
     *	&lt;flow name="save"&gt;
     *		&lt;objectstore:store key="flowVars['currentUserId']" value-ref="#[flowVars['boxAuthToken']]"/&gt;
     *	&lt;/flow&gt;
     * 
     * This flow will receive the same mule message the auth callback receives. If additionaly you also
     * provided a saveAuthTokenFlow, then any mutations done to the message there are also available in this flow
     */
    @Configurable
    @Optional
    private String postAuthFlow;
    
    /**
     * The http connector to be used when serving the authorization callback.
     * If {@link usesCallback} is false then this connector is not used.
     * 
     * If not provided, the default http connector under the key 'connector.http.mule.default' will be used.
     * However, specifying an https connector is adviced. 
     */
    @Configurable
    @Optional
    private org.mule.api.transport.Connector httpConnector;
    
    /**
     * Actual restore token flow egarly fetched
     */
    private Flow restoreTokenFlow;
    
    /**
     * Actual save token flow egarly fetched
     */
    private Flow saveTokenFlow;
    
    private Flow postAuthorizationFlow;
    
    private String authToken;
    
    /**
     * This method initiaes the box client and the auth callback.
     * Also, it fetches the save/restore flows (if specified). If those are specified
     * but don't exist in the registry, then IllegalArgumentException is thrown
     * 
     * @throws MuleException
     * @throws IllegalArgumentException if restore/save token flows are specified but don't exist
     */
    @Start
    public void init() throws MuleException {
    	ClientConfig clientConfig = new DefaultClientConfig();
    	clientConfig.getFeatures().put(JSONConfiguration.FEATURE_POJO_MAPPING, Boolean.TRUE);
    	clientConfig.getClasses().add(MultiPartWriter.class);
    	clientConfig.getClasses().add(MimeMultipartProvider.class);
    	clientConfig.getClasses().add(InputStreamProvider.class);
    	clientConfig.getClasses().add(FormProvider.class);
    	clientConfig.getClasses().add(FormMultivaluedMapProvider.class);
    	
    	this.client = Client.create(clientConfig);
    	
    	this.authCallback = new AuthCallbackAdapter(this.muleContext, this);
		this.authCallback.setLocalPort(this.getCallbackPort());
		this.authCallback.setAsync(false);

		if (this.usesCallback) {
			this.postAuthorizationFlow = this.fetchFlow(this.postAuthFlow);
			this.authCallback.start();
    	}
		
		this.restoreTokenFlow = this.fetchFlow(this.restoreAuthTokenFlow);
		this.saveTokenFlow = this.fetchFlow(this.saveAuthTokenFlow);
    }
    
    @Stop
    public void onStop() throws MuleException {
    	if (this.usesCallback) {
    		this.authCallback.stop();
    	}
    }
    
    
    /**
     * Get and access ticket using the configured apiKey. Optionally, you can ask the connector to automatically
     * redirect the browser to box authorization page so that the user can enter his credentials. This is done
     * by invoking {@link org.mule.modules.box.BoxConnector.authorizeTicket(MuleMessage, String)}
     * 
     * Otherwise, the user needs to manually go to {@link https://www.box.com/api/1.0/auth/&lt;&lt;ticket&gt;&gt;}
     * 
     * Either way, the connector <b>WILL NOT</b> be responsible for storing this ticket.
     * 
     * For more info look at {@link http://developers.box.com/get-started/}
     * 
     * {@sample.xml ../../../doc/box-connector.xml.sample box:get-ticket}
     * 
     * @param message the current mule message
     * @param redirect if true, then the browser will be automatically redirected to https://www.box.net/api/1.0/auth/&lt;&lt;ticket&gt;&gt;
     *  
     * @return the obtained ticket
     */
    @Processor
    @Inject
    public String getTicket(MuleMessage message, @Optional @Default("true") Boolean redirect) {
    	
    	GetTicketResponse response = JerseyUtils.get(
    										this.client.resource(AUTH_URL)
								    			.queryParam("action", "get_ticket")
								    			.queryParam("api_key", this.apiKey)
									    		.accept(MediaType.APPLICATION_XML),
								    		GetTicketResponse.class); 
    	if (response.isValid()) {
    		
    		String ticket = response.getTicket();
    		
    		if (logger.isDebugEnabled()) {
    			logger.debug(String.format("Fetched ticket with apiKey %s and obtained %s", this.apiKey, ticket));
    		}

    		if (redirect) {
    			this.authorizeTicket(message, ticket);
    		}
    		
    		return ticket;
    	
    	} else {
    		throw new RuntimeException(String.format("Failed to obtain ticket. Box response was %s", response.getStatus()));
    	}
    	
    }
    
    /**
     * Redirects the browser to box authorization page so that the user can enter his credentials.
     * The new location will be {@link https://www.box.net/api/1.0/auth/&lt;&lt;ticket&gt;&gt;}
     * 
     * {@sample.xml ../../../doc/box-connector.xml.sample box:authorize-ticket}
     * 
     * @param message the current mule message
     * @param ticket the ticket to be authorized
     */
    @Processor
    @Inject
    public void authorizeTicket(MuleMessage message, String ticket) {
    	String redirectUrl = "https://www.box.com/api/1.0/auth/" + ticket;
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug(String.format("redirecting to %s for authorizing ticket %s", redirectUrl, ticket));
    	}
    	
    	message.setOutboundProperty("http.status", "302");
    	message.setOutboundProperty("Location", redirectUrl);
    }

    /**
     * After the user authenticates the ticket obtained with the get-ticket processor,
     * there're two ways to get the required auth token:
     * 
     * <ol>
	 *	<li>
	 *		You can configure box.net to make a callback returning the ticket and authToken, in which case you need to set the
	 * 		usesCallback and callbackPath config attributes accordingly 
	 *	</li>
	 *	<li>
	 *		You can use this processor to obtain the authentication token explicitly.
	 *  </li>
	 *	</ol>
	 *
	 *  Either way, this connector will retain the authToken in memory and will use it in all operations.
	 *  
	 *  For more info look at http://developers.box.net/w/page/12923915/ApiAuthentication
     *
     * {@sample.xml ../../../doc/box-connector.xml.sample box:auth-token}
     *
     * @param message the current mule message
     * @param ticket the ticket to authenticate against.
     * @return an instance of {@link org.mule.modules.box.model.User} with information about the current user
     * @throws IllegalArgumentException if the ticket does not match a logged user
     */
    @Processor
    @Inject
    public User authToken(MuleMessage message, String ticket) {
    	

    	GetAuthTokenResponse response = JerseyUtils.get(
    									this.client.resource(AUTH_URL)
							    			.queryParam("action", "get_auth_token")
							    			.queryParam("api_key", this.apiKey)
							    			.queryParam("ticket", ticket)
								    		.accept(MediaType.APPLICATION_XML),
							    		GetAuthTokenResponse.class); 
    	
    	if (response.isNotLoggedIn()) {
    		String msg = "Failed to obtain authToken using ticket " + ticket + ". Not logged in";
       	 	logger.error(msg);
       	 	throw new IllegalStateException(msg);
    	}
    	
    	if (response.isValid()) {
    		String authToken = response.getAuthToken();
    		
    		if (logger.isDebugEnabled()) {
    			logger.debug(String.format("ticket %s mapped to authToken: %s", ticket, authToken));
    		}
    		
    		this.saveAuthToken(message, ticket, authToken);
    		return response.getUser();
    		
    	} else {
    		throw new RuntimeException(String.format("Status %s was obtained while fetching access token", response.getStatus()));
    	}
    }

    /**
     * Retrieves information about a given folder. If the folderId parameter is not
     * provided or equals 0, then the root folder will be returned.
     * 
     * {@sample.xml ../../../doc/box-connector.xml.sample box:get-folder}
     * 
     * @param message the current mule message
     * @param folderId the id of the fodler you want to get. 0 means root
     * @return an instance of {@link org.mule.modules.box.model.Folder}
     */
    @Processor
    @Inject
    public Folder getFolder(MuleMessage message, @Optional @Default("0") String folderId) {
    	return JerseyUtils.secureGet(
    				this.client.resource(BASE_URL + "folders")
	    				.path(folderId)
	    				.accept(MediaType.APPLICATION_JSON),
    				Folder.class, apiKey, this.getAuthToken(message));
    }
    
    /**
     * Creates a new folder and returns a folder object with all its associated information
     * 
     * {@sample.xml ../../../doc/box-connector.xml.sample box:create-folder}
     * 
     * @param message the current mule message
     * @param parentId the id of the parent folder. If not provided then the root will be used
     * @param folderName the name of the folder
     * @return an instance of {@link org.mule.modules.box.model.Folder} representing the newly created folder
     */
    @Processor
    @Inject
    public Folder createFolder(MuleMessage message, @Optional @Default("0") String parentId, String folderName) {
    	return JerseyUtils.securePost(
    							this.client.resource(BASE_URL + "folders")
	    							.accept(MediaType.APPLICATION_JSON)
	    							.type(MediaType.APPLICATION_JSON)
	    							.entity(new CreateFolderRequest(folderName, parentId)),
	    						Folder.class, this.apiKey, this.getAuthToken(message));
    }
    
    
    /**
     * Returns the items of a folder
     * 
     * {@sample.xml ../../../doc/box-connector.xml.sample box:get-folder-items}
     * 
     * @param message the current mule message
     * @param folderId the id of the folder you want to inspect. If not provided then the root folder is assumed
     * @return an instance of {@link org.mule.modules.box.model.FolderItems}
     */
    @Processor
    @Inject
    public FolderItems getFolderItems(MuleMessage message, @Optional @Default("0") String folderId) {
    	return JerseyUtils.secureGet(
    			this.client.resource(BASE_URL)
	    			.path("folders")
	    			.path(folderId)
	    			.path("items")
	    			.accept(MediaType.APPLICATION_JSON)
    			, FolderItems.class, this.apiKey, this.getAuthToken(message));
    }
    
    /**
     * Deletes a folder
     * 
     * {@sample.xml ../../../doc/box-connector.xml.sample box:delete-folder}
     * 
     * @param message the current mule message
     * @param folderId the id of the folder to be deleted
     * @param recursive Whether to delete this folder if it has items inside of it
     */
    @Processor
    @Inject
    public void deleteFolder(MuleMessage message, String folderId, @Optional @Default("true") Boolean recursive) {
    	JerseyUtils.secureDelete(
    			this.client.resource(BASE_URL)
    				.path("folders")
    				.path(folderId)
    				.queryParam("recursive", recursive.toString())
    				.accept(MediaType.APPLICATION_JSON)
    			, String.class, this.apiKey, this.getAuthToken(message));
    			
    	
    }
    
    /**
     * Creates a new file with the contents of a {@link java.io.InputStream}.
     * You need to take in count that since this is a stream, using the option of including a verification hash
     * will cause the contents of the input stream to be fully read and loaded in memory. 
     * 
     * {@sample.xml ../../../doc/box-connector.xml.sample box:upload-stream}
     * 
     * @param message the current mule message
     * @param folderId the id of the target folder.
     * @param filename the name you want the file to have at box.
     * @param content a {@link java.io.InputStream} with the contents of the file. This processor <b>IS NOT</b> responsible for closing it
     * @param includeHash if true a sha1 hash of the file will be calculated prior to upload. Box will use that hash
     * 			to verify that the content's hasn't been corrupted.
     * @return an instance of {@link org.mule.modules.box.model.File} with the information of the created file
     */
    @Processor
    @Inject
    public UploadFileResponse uploadStream(
    		MuleMessage message,
    		@Optional @Default("0") String folderId,
    		String filename,
    		@Optional @Default("#[payload]") InputStream content,
    		@Optional @Default("false") boolean includeHash) {
    	
    	WebResource.Builder resource = this.client.resource(BASE_URL + "files/content").type(MediaType.MULTIPART_FORM_DATA);
    	
    	if (includeHash) {
			resource.header("Content-MD5", this.hash(content));
    	}
    	
    	FormDataMultiPart form = new FormDataMultiPart();
		form.field("folder_id", folderId);
		form.bodyPart(new StreamDataBodyPart(filename, content));
    	resource.entity(form);
    	
    	return JerseyUtils.securePost(resource, UploadFileResponse.class, this.apiKey, this.getAuthToken(message));
    }
    
    private String hash(InputStream content) {
    	byte[] bytes = null;
		try {
			bytes = IOUtils.toByteArray(content);
		} catch (IOException e) {
			throw new RuntimeException("Error generating sha1 for content", e);
		}
		
		Formatter formatter = new Formatter();
		try {
			for (byte b : bytes) {
				formatter.format("%02x", b);
			}
			return formatter.toString();
		} finally {
			formatter.close();
		}
    }
    
    /**
     * Receives the path of a file in local storage and uploads its content
     *
     * {@sample.xml ../../../doc/box-connector.xml.sample box:upload-path}
     * 
     * @param message the current mule message
     * @param path the path of the file in local storage
     * @param folderId the id of the target folder.
     * @param filename the name you want the file to have at box. If not provided, the name on current storage will be used
     * @param includeHash if true a sha1 hash of the file will be calculated prior to upload. Box will use that hash
     * 			to verify that the content's hasn't been corrupted. 
     *        
     * @return an instance of {@link org.mule.modules.box.model.File} with the information of the created file
     */
    @Processor
    @Inject
    public UploadFileResponse uploadPath(
    		MuleMessage message,
    		String path, 
    		@Optional @Default("0") String folderId,
    		@Optional String filename,
    		@Optional @Default("false") boolean includeHash) {
    	
    	
		java.io.File file = new java.io.File(path);
    		
		if (!file.exists()) {
			throw new IllegalArgumentException(String.format("File %s does not exist", path));
		}
		
		if (StringUtils.isBlank(filename)) {
			filename = file.getName();
		}
    	
		byte[] content = null;
		
		try {
			FileUtils.readFileToByteArray(file);
		} catch (IOException e) {
			throw new RuntimeException(String.format("Error reading file at %s", path), e);
		}
		
		return this.uploadStream(message, folderId, filename, new ByteArrayInputStream(content), includeHash);
    }
    
    /**
     * Deletes a file
     * 
     * {@sample.xml ../../../doc/box-connector.xml.sample box:delete-file}
     * 
     * @param message the current mule message
     * @param fileId the id of the file to be deleted
     * @param etag if provided, it will be used to verify that no newer version of the file is available at box
     */
    @Processor
    @Inject
    public void deleteFile(MuleMessage message, String fileId, @Optional String etag) {
    	WebResource.Builder resource = this.client.resource(BASE_URL + "files").path(fileId).accept(MediaType.APPLICATION_JSON);
    	
    	if (!StringUtils.isBlank(etag)) {
    		resource.header("If-Match", etag);
    	}
    	
    	JerseyUtils.secureDelete(resource, String.class, this.apiKey, this.getAuthToken(message));
    }
    

    /**
     * Create a new user in box.net
     *
     * {@sample.xml ../../../doc/box-connector.xml.sample box:register-new-user}
     *
     * @param email the user's email
     * @param password the user's password
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.RegisterNewUserResponse} with
     * 			data about the operation status and info about the newly created user (if successful)
     */
//    @Processor
//    public RegisterNewUserResponse registerNewUser(String email, String password) {
//    	if (logger.isDebugEnabled()) {
//    		logger.debug("about to create user with email: " + email + " and pass: " + password);
//    	}
//    	
//    	final RegisterNewUserRequest registerNewUserRequest = BoxRequestFactory.createRegisterNewUserRequest(apiKey, email, password);
//    	return this.execute(new BoxClosure<RegisterNewUserResponse>() {
//    		
//    		@Override
//    		public RegisterNewUserResponse execute() throws IOException, BoxException {
//    			return client.registerNewUser(registerNewUserRequest);
//    		}
//		}, "registerNewUser");
//    }
    
    
    /**
     * Makes a public share of a file or folder
     *
     * {@sample.xml ../../../doc/box-connector.xml.sample box:public-share}
     *
     * @param muleMessage the current mule message
     * @param target The type of item to be shared.  This can be set as 'file' or 'folder'. Any other value will throw a {@link IllegalArgumentException}
     * @param targetId The id of the item you wish to share.  If the target is a folder, this will be the folder_id.  If the target is a file, this will be the file_id.
     * @param password The password to protect the folder or file.
     * @param message An message to be included in a notification email.
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.PublicShareResponse} with
     * 			data about the operation status and info about the shared folder (if successful)
     * @throws {@link IllegalArgumentException} if target is invalid
     */
//    @Processor
//    @Inject
//    public PublicShareResponse publicShare(
//									MuleMessage muleMessage,
//    								Target target,
//									String targetId,
//									String password,
//									String message) {
//    	
//    	String authToken = this.getAuthToken(muleMessage);
//    	
//    	if (logger.isDebugEnabled()) {
//    		logger.debug("about to share folder with params:" +
//    					"\ntarget: " + target +
//    					"\ntargetId: " + targetId + 
//    					"\npassword: " + password + 
//    					"\nmessage: " + message);
//    	}
//    	
//    	final PublicShareRequest publicShareRequest = BoxRequestFactory.createPublicShareRequest(
//    			apiKey,	authToken, target.name(), targetId, password, message, null);
//    	
//    	return this.execute(new BoxClosure<PublicShareResponse>() {
//    		
//    		@Override
//    		public PublicShareResponse execute() throws IOException, BoxException {
//    			return client.publicShare(publicShareRequest);
//    		}
//		}, "publicShare");
//    }
    
    /**
     * This processor unshares a public shared file or folder
     * 
     * {@sample.xml ../../../doc/box-connector.xml.sample box:public-unshare}
     * 
     * @param message the current mule message
     * @param target shoud be either 'file' or 'folder'
     * @param targetId is id of a file or folder to be unshared
     * @return  On a successful result, the status will be 'unshare_ok'. If the result wasn't successful, the status field can be: 'unshare_error', 'wrong_node', 'not_logged_in', 'application_restricted'.
     * @throws {@link IllegalArgumentException} if target is invalid
     */
//    @Processor
//    @Inject
//    public String publicUnshare(MuleMessage message, Target target, String targetId) {
//    	String authToken = this.getAuthToken(message);
//    	final PublicUnshareRequest request = BoxRequestFactory.createPublicUnshareRequest(apiKey, authToken, target.name(), targetId);
//    	
//    	PublicUnshareResponse response = this.execute(new BoxClosure<PublicUnshareResponse>() {
//    		
//    		@Override
//    		public PublicUnshareResponse execute() throws IOException, BoxException {
//    			return client.publicUnshare(request);
//    		}
//		}, "publicUnshare");
//    	
//    	return response.getStatus();
//    }
    
    /**
     * This processor privately shares a file or folder with another user(s).
     * 'target' param, 'target_id' is . 'emails' params is an array of emails
     * of users' to share files with. if 'notify' param is , 'message' param .
     * 
     * Note: currently only files can be shared privately.
     * 
     * {@sample.xml ../../../doc/box-connector.xml.sample box:private-share}
     * 
     * @param muleMessage the current mule message
     * @param target should be either 'file' or 'folder'
     * @param targetId the id of the file or folder to be shared
     * @param csvMails comma separated list of email addresses of the users that will receive the share
     * @param notify if true, then a notification email will be sent to users. Optional parameter, defaults to true
     * @param message is a message to be included in the notification email. Optional parameter, defaults to an empty string
     * @return if successful will be 'private_share_ok'. Otherwise can be: 'private_share_error', 'wrong_node', 'not_logged_in', 'application_restricted'.
     * @throws {@link IllegalArgumentException} if target is invalid or csvMails is null or empty
     */
//    @Processor
//    @Inject
//    public String privateShare( MuleMessage muleMessage,
//    							Target target,
//    							String targetId,
//    							String csvMails,
//    							@Optional @Default("true") Boolean notify,
//    							@Optional @Default("") String message )	{
//    	
//    	String authToken = this.getAuthToken(muleMessage);
//    	
//    	if (StringUtils.isEmpty(csvMails)) {
//    		throw new IllegalArgumentException("csvMails cannot be empty");
//    	}
//    	
//    	final PrivateShareRequest request = BoxRequestFactory.createPrivateShareRequest(
//    					apiKey, authToken, target.name(), targetId, csvMails.split(","), message, notify);
//    	
//    	PrivateShareResponse response = this.execute(new BoxClosure<PrivateShareResponse>() {
//    		
//    		@Override
//    		public PrivateShareResponse execute() throws IOException, BoxException {
//    			return client.privateShare(request);
//    		}
//		}, "privateShare");
//    	
//    	return response.getStatus();
//    }
    
    /**
     * This processor is used to get a user's files and folders tree.
     * 
     * 'folderId' param defines root folder from which the tree begins.
     * 'csvParams' is comma separated list where you can set additional parameters,
     * which are: onelevel - make a tree of one level depth, so you will get
     * only files and folders stored in folder which folder_id you have
     * provided. nofiles - include folders only in result tree, no files. nozip
     * - do not zip tree xml.
     * 
     * On successful result you will receive 'listing_ok' as status and the tree xml.
     * if you haven't set 'nozip' as a parameter (it's set by default), then you have to unzip it. Then you will get xml like
     * this: (note that updatedand createdare UNIX timestamps in PST).
     *
     * {@sample.xml ../../../doc/box-connector.xml.sample box:get-tree-structure}
     *
     * @param message the current mule message
     * @param folderId The ID of the root folder from which the tree begins.  If this value is "0", the user's full account tree is returned. Defaults to zero
     * @param csvParams comma separated list of params. This is optional and defaults to 'nozip'
     * @param encoding optional parameter to specify the encoding to use when decoding BASE64. Defaults to UTF-8
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.GetAccountTreeResponse} with
     * 			data about the operation status and info about the inspected folder (if successful)
     */
//    @Processor
//    @Inject
//    public GetAccountTreeResponse getTreeStructure(
//    		MuleMessage message,
//    		@Optional @Default("0") String folderId,
//			@Optional @Default("nozip") String csvParams,
//			final @Optional @Default("UTF-8") String encoding) {
//    	
//    	String authToken = this.getAuthToken(message);
//    	if (logger.isDebugEnabled()) {
//    		logger.debug("fetching tree structure with params:\n" +
//    					"\nfolderId: " + folderId + 
//    					"\ncsvParams: " + csvParams);
//    	}
//    	
//    	String[] params = StringUtils.isEmpty(csvParams) ? null : csvParams.split(",");
//    	final GetAccountTreeRequest getAccountTreeRequest = BoxRequestFactory.createGetAccountTreeRequest(
//    			apiKey, authToken, folderId, params);
//    	
//    	return this.execute(new BoxClosure<GetAccountTreeResponse>() {
//    		
//    		@Override
//    		public GetAccountTreeResponse execute() throws IOException,	BoxException {
//    			GetAccountTreeResponse response = client.getAccountTree(getAccountTreeRequest);
//    			
//    			if (response.getEncodedTree() != null) {
//    				response.setEncodedTree(decode(response.getEncodedTree(), encoding));
//    			}
//    			
//    			return response;
//    		}
//		}, "getTreeStructure");
//    }
    
    
    /**
     * Downloads a file an returns its contents as a byte[] 
     *
     * {@sample.xml ../../../doc/box-connector.xml.sample box:download}
     *
     * @param message the current mule message
     * @param fileId the id of the file we want to download
     * @return the file's contents as a byte array
     */
//    @Processor
//    @Inject
//    public byte[] download(MuleMessage message, String fileId) {
//    	
//    	String authToken = this.getAuthToken(message);
//    	if (logger.isDebugEnabled()) {
//    		logger.debug("About to download file with id: " + fileId);
//    	}
//    	
//    	final DownloadRequest downloadRequest = BoxRequestFactory.createDownloadRequest(authToken, fileId, false, null);
//    	DownloadResponse response = this.execute(new BoxClosure<DownloadResponse>() {
//    		
//    		@Override
//    		public DownloadResponse execute() throws IOException, BoxException {
//    			return client.download(downloadRequest);
//    		}
//    		
//		}, "download");
//    	
//    	return response.getRawData();
//    }
    
    
    /**
     * Logs out the user associated with the authorization token
     *
     * {@sample.xml ../../../doc/box-connector.xml.sample box:logout}
     *
     * @param message the current mule message
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.LogoutResponse} with data about the operation status
     */
//    @Processor
//    @Inject
//    public LogoutResponse logout(MuleMessage message) {
//    	String authToken = this.getAuthToken(message);  	
//    	if (logger.isDebugEnabled()) {
//    		logger.debug("logging off authToken: " + authToken);
//    	}
//    	
//    	final LogoutRequest logoutRequest = BoxRequestFactory.createLogoutRequest(apiKey, authToken);
//    	
//    	return this.execute(new BoxClosure<LogoutResponse>() {
//    		
//    		@Override
//    		public LogoutResponse execute() throws IOException, BoxException {
//    			return client.logout(logoutRequest);
//    		}
//		}, "logout");
//    }
    
    /**
    * This method is used to verify user registration email
    * 
    * {@sample.xml ../../../doc/box-connector.xml.sample box:verify-registration-email}
    * 
    * @param message the current mule message
    * @param loginName The login username of the user for which you would like to verify registration.
    * @return Upon a successful registration, the return value will be 'email_ok'.
	*		If registration was not successful, it can be:
	*		'email_invalid' - The login provided is not a valid email address.
	*		'email_already_registered' - The login provided is already registered by another user.
	*		'application_restricted'- You provided an invalid api_key, or the api_key is restricted from calling this function. 
    */ 
//    @Processor
//    @Inject
//    public String verifyRegistrationEmail(MuleMessage message, String loginName) {
//
//        if (logger.isDebugEnabled()) {
//        	logger.debug("checking registration email for loginName: " + loginName);
//        }
//        
//        final VerifyRegistrationEmailRequest request = BoxRequestFactory.createVerifyRegistrationEmailRequest();
//        request.setLoginName(loginName);
//        request.setApiKey(apiKey);
//        
//        return this.execute(new BoxClosure<VerifyRegistrationEmailResponse>() {
//        	
//        	@Override
//        	public VerifyRegistrationEmailResponse execute() throws IOException, BoxException {
//        		return client.verifyRegistrationEmail(request);
//        	}
//		}, "verifyRegistrationEmail").getStatus();
//    }
    
    /**
     * This processor returns all the user's tags.
     * 
     * On successful you will get an xml representing the tags that looks like this:
     * 
     * <?xml version="1.0"?> <tags> <tag id="37"> music </tag> <tag id="38"> mp3
     * </tag> </tags> If the result wasn't successful, status field can be:
     * not_logged_id, application_restricted.
     * 
     * {@sample.xml ../../../doc/box-connector.xml.sample box:export-tags}
     * 
     * @param message the current mule message
     * @param encoding encoding to use when decoding from BASE64. Optional, defaults to UTF-8
     * @return a String xml representing the tags
     */
//    @Processor
//    @Inject
//    public String exportTags(MuleMessage message, @Optional @Default("UTF-8") String encoding) {
//    	String authToken = this.getAuthToken(message);
//    	final ExportTagsRequest request = BoxRequestFactory.createExportTagsRequest(apiKey, authToken);
//    	
//    	if (logger.isDebugEnabled()) {
//    		logger.debug("getting tags");
//    	}
//    	
//    	ExportTagsResponse response = this.execute(new BoxClosure<ExportTagsResponse>() {
//    		
//    		@Override
//    		public ExportTagsResponse execute() throws IOException, BoxException {
//    			 return client.exportTags(request);
//    			
//    		}
//    		
//		}, "exportTags");
//    	
//    	if (response.getStatus().equals("export_tags_ok")) {
//    		return this.decode(response.getEncodedTags(), encoding);
//    	}
//    	
//    	throw new RuntimeException("Error retrieving tags. Box.net replied " + response.getStatus());
//    }
    
    /**
     * This processor moves a file or folder to another folder.
     * 
     * 
     * On a successful result, status will be 's_move_node'. If the result
     * wasn't successful, status field can be: 'e_move_node', 'not_logged_in',
     * 'application_restricted'.
     * 
     * {@sample.xml ../../../doc/box-connector.xml.sample box:move}
     * 
     * @param message the current mule message
     * @param target can be either 'file' or 'folder' depending on what do you
     * @param targetId is the id of a file or folder to be moved
     * @param destinationId is the destination folder id.
     * @return if successful 's_move_node'. Otherwise it can be 'e_move_node', 'not_logged_in',
     * 'application_restricted'.
     */
//    @Processor
//    @Inject
//    public String move(MuleMessage message, Target target, String targetId, String destinationId) {
//    	String authToken = this.getAuthToken(message);
//    	
//    	if (logger.isDebugEnabled()) {
//    		logger.debug("moving " + target + " " + targetId + " to " + destinationId);
//    	}
//    	
//    	final MoveRequest request = BoxRequestFactory.createMoveRequest(apiKey, authToken, target.name(), targetId, destinationId);
//    	
//    	MoveResponse response = this.execute(new BoxClosure<MoveResponse>() {
//    		
//    		@Override
//    		public MoveResponse execute() throws IOException, BoxException {
//    			return client.move(request);
//    		}
//		}, "move");
//    	
//    	return response.getStatus();
//    }
    
    /**
     * This processor renames a file or folder.
     * 
     * {@sample.xml ../../../doc/box-connector.xml.sample box:move} 
     * 
     * @param message the current mule message
     * @param target can be either 'file' or 'folder' depending on what you want to rename
     * @param targetId is the id of a file or folder to be renamed
     * @param newName is the new name for a file or folder
     * @return if successful will be 's_rename_node'. Otherwise it can be: 'e_rename_node', 'not_logged_in', 'application_restricted'
     */
//    @Processor
//    @Inject
//    public String rename(MuleMessage message, Target target, String targetId, String newName) {
//    	String authToken = this.getAuthToken(message);
//    	
//    	if (logger.isDebugEnabled()) {
//    		logger.debug("renaming " + target + " " + targetId + " to " + newName);
//    	}
//    	
//    	final RenameRequest request = BoxRequestFactory.createRenameRequest(apiKey, authToken, target.name(), targetId, newName);
//    	
//    	RenameResponse response = this.execute(new BoxClosure<RenameResponse>() {
//    		
//    		@Override
//    		public RenameResponse execute() throws IOException, BoxException {
//    			return client.rename(request);
//    		}
//		}, "rename");
//    	
//    	return response.getStatus();
//    }
    
    /**
     * Gets information about a file
     * 
     * {@sample.xml ../../../doc/box-connector.xml.sample box:get-file-info}
     * 
     * @param message the current mule message
     * @param fileId the id of the file you want info about
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.GetFileInfoResponse}
     */
//    @Processor
//    @Inject
//    public GetFileInfoResponse getFileInfo(MuleMessage message, String fileId) {
//    	String authToken = this.getAuthToken(message);
//    	if (logger.isDebugEnabled()) {
//    		logger.debug("getting information about file: " + fileId);
//    	}
//    	
//    	final GetFileInfoRequest request = BoxRequestFactory.createGetFileInfoRequest(apiKey, authToken, fileId);
//    	return this.execute(new BoxClosure<GetFileInfoResponse>() {
//    		
//    		@Override
//    		public GetFileInfoResponse execute() throws IOException, BoxException {
//    			return client.getFileInfo(request);
//    		}
//		}, "getFileInfo");
//    }
//    
    /**
     * This processor adds file or folder to tags list. 
     * 
     * {@sample.xml ../../../doc/box-connector.xml.sample box:add-to-tag}
     * 
     * @param message the current mule message
     * @param csvTags comma separated list of tags
     * @param target can be either 'file' or 'folder' depending on what do you want to add
     * @param targetId the id of a file or folder to be added
     * @return 'addtotag_ok' if successful. Otherwise addtotag_error.
     * @throws {@link IllegalArgumentException} if target is invalid or csvTags is empty
     */
//    @Processor
//    @Inject
//    public String addToTag(MuleMessage message, String csvTags, Target target, String targetId) {
//    	String authToken = this.getAuthToken(message);
//    	
//    	if (StringUtils.isEmpty(csvTags)) {
//    		throw new IllegalArgumentException("csvTags cannot be empty");
//    	}
//    	
//    	if (logger.isDebugEnabled()) {
//    		logger.debug("adding tags to " + target + " " + targetId + ": " + csvTags);
//    	}
//    	
//    	final AddToTagRequest request = BoxRequestFactory.createAddToTagRequest(apiKey, authToken, csvTags.split(","), target.name(), targetId);
//    	AddToTagResponse response = this.execute(new BoxClosure<AddToTagResponse>() {
//    		
//    		@Override
//    		public AddToTagResponse execute() throws IOException, BoxException {
//    			return client.addToTag(request);
//    		}
//		}, "addToTag");
//    	
//    	return response.getStatus();
//    }
    
    /**
     * 
     * This processor sets a description to a file or folder.
     * 
     * {@sample.xml ../../../doc/box-connector.xml.sample box:set-description}
     * 
     * @param message the current mule message
     * @param target can be either 'file' or 'folder'
     * @param targetId the id of the folder/file you want to modify
     * @param description the description you want to set
     * @return 's_set_description' if successful. 'e_set_description' otherwise.
     */
//    @Processor
//    @Inject
//    public String setDescription(MuleMessage message, Target target, String targetId, String description) {
//    	String authToken = this.getAuthToken(message);
//    	
//    	if (logger.isDebugEnabled()) {
//    		logger.debug("setting description of " + target + " " + targetId + " to:" + description);
//    	}
//    	
//    	final SetDescriptionRequest request = BoxRequestFactory.createSetDescriptionRequest(apiKey, authToken, target.name(), targetId, description);
//    	SetDescriptionResponse response = this.execute(new BoxClosure<SetDescriptionResponse>() {
//    		
//    		@Override
//    		public SetDescriptionResponse execute() throws IOException, BoxException {
//    			return client.setDescription(request);
//    		}
//		}, "setDescription");
//    	
//    	return response.getStatus();
//    }
    
    public String getAuthToken(MuleMessage message) {
    	String token = null;
    	
    	if (this.restoreTokenFlow == null) {
    	
    		token = this.authToken;
    	
    	} else {
    		MuleMessage restoreMessage = FlowUtils.callFlow(this.restoreTokenFlow, new DefaultMuleMessage(message)); 
    		Object payload = restoreMessage.getPayload();
    		
    		if (payload instanceof String) {
    			token = (String) payload;
    			return token;
    		} else {
    			throw new IllegalArgumentException(
    					String.format("A String payload was expected after invoking restore token flow '%s', but %s was found instead",
    							this.restoreAuthTokenFlow,
    							payload == null ? "null" : payload.getClass().getCanonicalName()
    							)
    					);
    		}
    	}
    	
    	if (StringUtils.isBlank(token)) {
    		throw new IllegalStateException("Auth token not obtained yet");
    	}
    	
    	return token;
    }
    
    private Flow fetchFlow(String flowname) {
    	if (StringUtils.isBlank(flowname)) {
    		return null;
    	}
    	
    	Flow flow = FlowUtils.getFlow(flowname, muleContext);
    	
    	if (flow == null) {
    		throw new IllegalArgumentException(String.format("flow %s doesn't exists", flowname));
    	}
    	
    	return flow;
    }
    
   public MuleMessage saveAuthToken(MuleMessage message, String ticket, String authToken) {
	   
	   if (StringUtils.isBlank(ticket)) {
		   throw new IllegalArgumentException("auth process did not return a ticket");
	   }
	   
	   if (StringUtils.isBlank(authToken)) {
		   throw new IllegalArgumentException("auth process did not return an auth token");
	   }
	   
	   MuleMessage copy = new DefaultMuleMessage(message);
	   copy.setInvocationProperty(BOX_AUTH_TICKET, ticket);
	   copy.setInvocationProperty(BOX_AUTH_TOKEN, authToken);
	   
	   if (this.saveTokenFlow == null) {
			this.authToken = authToken;
	   } else {
			FlowUtils.callFlow(this.saveTokenFlow, copy);
	   }
	   
	   this.postAuth(copy);
	   
	   return copy;
    }
   
   private void postAuth(MuleMessage message) {
	   if (this.postAuthorizationFlow != null) {
		   if (logger.isDebugEnabled()) {
			   logger.debug(String.format("invoking post authorization flow %s with message %s", this.postAuthFlow, message.toString()));
		   }
		   FlowUtils.callFlow(this.postAuthorizationFlow, message);
	   } else {
		   if (logger.isDebugEnabled()) {
			   logger.debug("No post auth flow specified");
		   }
	   }
   }
    
	public String getCallbackPath() {
		return callbackPath;
	}

	public void setCallbackPath(String callbackPath) {
		this.callbackPath = callbackPath;
	}

	public void setApiKey(String apiKey) {
		this.apiKey = apiKey;
	}
	
	public Integer getCallbackPort() {
		return callbackPort;
	}

	public void setCallbackPort(Integer callbackPort) {
		this.callbackPort = callbackPort;
	}
	
	public boolean isUsesCallback() {
		return usesCallback;
	}

	public void setUsesCallback(boolean usesCallback) {
		this.usesCallback = usesCallback;
	}

	@Override
	public void setMuleContext(MuleContext context) {
		this.muleContext = context;
	}

	public String getRestoreAuthTokenFlow() {
		return restoreAuthTokenFlow;
	}

	public void setRestoreAuthTokenFlow(String restoreAuthTokenFlow) {
		this.restoreAuthTokenFlow = restoreAuthTokenFlow;
	}

	public String getSaveAuthTokenFlow() {
		return saveAuthTokenFlow;
	}

	public void setSaveAuthTokenFlow(String saveAuthTokenFlow) {
		this.saveAuthTokenFlow = saveAuthTokenFlow;
	}

	public String getApiKey() {
		return apiKey;
	}

	public org.mule.api.transport.Connector getHttpConnector() {
		return httpConnector;
	}

	public void setHttpConnector(org.mule.api.transport.Connector httpConnector) {
		this.httpConnector = httpConnector;
	}

	public String getPostAuthFlow() {
		return postAuthFlow;
	}

	public void setPostAuthFlow(String postAuthFlow) {
		this.postAuthFlow = postAuthFlow;
	}
	
}
