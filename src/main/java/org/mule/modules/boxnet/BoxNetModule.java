/**
 * Mule Development Kit
 * Copyright 2010-2011 (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file was automatically generated by the Mule Development Kit
 */
package org.mule.modules.boxnet;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.builder.ToStringBuilder;
import org.apache.log4j.Logger;
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Module;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.param.Default;
import org.mule.api.annotations.param.Optional;
import org.mule.api.transformer.TransformerException;
import org.mule.transformer.codec.Base64Decoder;

import cn.com.believer.songyuanframework.openapi.storage.box.BoxExternalAPI;
import cn.com.believer.songyuanframework.openapi.storage.box.constant.BoxConstant;
import cn.com.believer.songyuanframework.openapi.storage.box.factories.BoxRequestFactory;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.AddToTagRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.AddToTagResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.BoxResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.CreateFolderRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.CreateFolderResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.DeleteRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.DeleteResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.DownloadRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.DownloadResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.ExportTagsRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.ExportTagsResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.GetAccountTreeRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.GetAccountTreeResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.GetAuthTokenRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.GetAuthTokenResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.GetFileInfoRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.GetFileInfoResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.GetTicketRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.GetTicketResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.LogoutRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.LogoutResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.MoveRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.MoveResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.PrivateShareRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.PrivateShareResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.PublicShareRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.PublicShareResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.PublicUnshareRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.PublicUnshareResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.RegisterNewUserRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.RegisterNewUserResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.RenameRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.RenameResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.SetDescriptionRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.SetDescriptionResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.UploadRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.UploadResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.VerifyRegistrationEmailRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.VerifyRegistrationEmailResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.impl.simple.SimpleBoxImpl;
import cn.com.believer.songyuanframework.openapi.storage.box.objects.BoxException;

/**
 * Box.net Cloud Connector Module
 *
 * @author MuleSoft, Inc.
 * @author mariano.gonzalez@mulesoft.com
 */
@Module(name="boxnet", schemaVersion="1.0")
public class BoxNetModule {
    
private static final Logger logger = Logger.getLogger(BoxNetModule.class);
	
	private final BoxExternalAPI client = new SimpleBoxImpl();
	private static final String TARGET_FILE = "file";
	private static final String TARGET_FOLDER = "folder";
	
    /**
     * The API key obtained when registering a project with the Box platform.
     * For more information about this field please refer to {@link http://developers.box.net/}
     */
    @Configurable
    private String apiKey;
    
    
    /**
     * Get and access ticket using the configured apiKey.
     * With this ticket, the user needs to manually go to {@link https://www.box.net/api/1.0/auth/<ticket>}
     * 
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample boxnet:get-ticket}
     *
     * @return the ticket key
     */
    @Processor
    public String getTicket() {
    	
    	GetTicketResponse response = this.execute(new BoxClosure<GetTicketResponse>() {
    		
    		@Override
    		public GetTicketResponse execute() throws IOException, BoxException {
    			GetTicketRequest getTicketRequest = BoxRequestFactory.createGetTicketRequest(apiKey);
    			return client.getTicket(getTicketRequest);
    		}
		}, "getTicket");
    	
    	String ticket = response.getTicket();
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("Fetched ticket with apiKey " + this.apiKey + " and obtained: " + ticket);
    	}
    	
    	return ticket;
    }
    
    /**
     * Gets the authentication token for a particular ticket.
     * After the user manually logs into box.net using the ticket provided by
     * {@link org.mule.connector.boxnet.BoxNetModule.getTicket()}, one of two
     * things might happen depending on how the application is configured on box.net
     * side:
     * 
     * <ol>
	 *	<li>
	 *		You can configure box.net to make a callback returning the ticket and authToken, in which case you need to provide a http
	 *		inbound on your application (mule can help you do that but you're not forced to). For more information on this
	 *		option please look at {@link http://developers.box.net/w/page/12923915/ApiAuthentication}
	 *	</li>
	 *	<li>
	 *		You can use this processor to obtain the authentication token related to a certain ticket. You then need to store that token somehow
	 *		and use it in further processor operations. 
	 *  </li>
	 *	</ol>
     *
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample boxnet:get-auth-token}
     *
     * @param ticket the authentication ticket obtained with {@link org.mule.connector.boxnet.BoxNetModule.getTicket()}
     * @return the authentication token
     * @throws IllegalArgumentException if the ticket does not match a logged user
     */
    @Processor
    public String getAuthToken(String ticket) {
    	final GetAuthTokenRequest getAuthTokenRequest = BoxRequestFactory.createGetAuthTokenRequest(apiKey, ticket);
    	GetAuthTokenResponse getAuthTokenResponse = this.execute(new BoxClosure<GetAuthTokenResponse>() {
    		
    		@Override
    		public GetAuthTokenResponse execute() throws IOException, BoxException {
    			return client.getAuthToken(getAuthTokenRequest);
    		}
		}, "getAuthToken");
    	
         if (BoxConstant.STATUS_NOT_LOGGED_IN.equals(getAuthTokenResponse.getStatus())) {
             
        	 if (logger.isDebugEnabled()) {
            	 String msg = "Failed to obtain authToken using ticket " + ticket + ". Not logged in";
            	 logger.error(msg);
            	 throw new IllegalArgumentException(msg);
             }
         }
         
         String authToken = getAuthTokenResponse.getAuthToken();
         
         if (logger.isDebugEnabled()) {
        	 logger.debug("ticket " + ticket + "mapped to authToken: " + authToken);
         }
         
         return authToken;
    }
    

    /**
     * Create a new user in box.net
     *
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample boxnet:register-new-user}
     *
     * @param email the user's email
     * @param password the user's password
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.RegisterNewUserResponse} with
     * 			data about the operation status and info about the newly created user (if successful)
     */
    @Processor
    public RegisterNewUserResponse registerNewUser(String email, String password) {
    	if (logger.isDebugEnabled()) {
    		logger.debug("about to create user with email: " + email + " and pass: " + password);
    	}
    	
    	final RegisterNewUserRequest registerNewUserRequest = BoxRequestFactory.createRegisterNewUserRequest(apiKey, email, password);
    	return this.execute(new BoxClosure<RegisterNewUserResponse>() {
    		
    		@Override
    		public RegisterNewUserResponse execute() throws IOException, BoxException {
    			return client.registerNewUser(registerNewUserRequest);
    		}
		}, "registerNewUser");
    }
    
    /**
     * Create a new folder
     *
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample boxnet:create-folder}
     *
     * @param authToken the authentication token obtained with the ticket
     * @param parentFolderId the id of the parent folder
     * @param folderName the name of the folder you want to create
     * @param share specifies if the folder is shared. This parameter is optional and defaults to false
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.CreateFolderResponse} with
     * 			data about the operation status and info about the newly created folder (if successful)
     */
    @Processor
    public CreateFolderResponse createFolder(String authToken,
    										String parentFolderId,
    										String folderName,
    										@Optional @Default("false") Boolean share) {

    	if (logger.isDebugEnabled()) {
    		logger.debug("About to create folder:" +
    				"\nparentFolderId: " + parentFolderId +
    				"\nfolderName: " + folderName +
    				"\nshare: " + share);
    	}
    	
    	final CreateFolderRequest createFolderRequest =
    			BoxRequestFactory.createCreateFolderRequest(apiKey, authToken, parentFolderId, folderName, share);
    	
    	return this.execute(new BoxClosure<CreateFolderResponse>() {
    		
    		@Override
    		public CreateFolderResponse execute() throws IOException, BoxException {
    			
    			return client.createFolder(createFolderRequest);
    		}
		}, "create Folder");
    }
    
    /**
     * Receives a comma separated list of paths and uploads the corresponding
     * files.
     *
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample boxnet:upload-files}
     *
     * @param authToken the authentication token obtained with the ticket
     * @param folderId the id of the parent folder
     * @param csvPaths comma separated list of paths where the files are. Cannot be null or empty. Can we just want single comma-less file.
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.UploadResponse} with
     * 			data about the operation status and info about the newly uploaded files (if successful)
     */
    @Processor
    public UploadResponse uploadFiles(String authToken, String csvPaths, String folderId) {
    	if (StringUtils.isEmpty(csvPaths)) {
    		throw new IllegalArgumentException("you need to provide a path");
    	}
    	
    	final Map<String, File> files = new HashMap<String, File>();
    	
    	for (String path : csvPaths.split(",")) {
    		File file = new File(path);
    		
    		if (!file.exists()) {
    			throw new IllegalArgumentException("File " + path + " does not exist");
    		}
    		
    		files.put(file.getName(), file);
    	}
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("about to uploadFiles with parameters:" +
    				"\ncsvPaths: " + csvPaths +
    				"\nfolderId: " + folderId
    				);
    	}
    	
    	final UploadRequest uploadRequest = BoxRequestFactory.createUploadRequest(authToken, true, folderId, files);
    	
    	return this.execute(new BoxClosure<UploadResponse>() {
    		
    		@Override
    		public UploadResponse execute() throws IOException, BoxException {
    			return client.upload(uploadRequest);
    		}
		}, "uploadFiles");
    }
    
    /**
     * Receives an input stream and uploads its content as a file
     *
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample boxnet:upload-stream}
     *
     * @param authToken the authentication token obtained with the ticket
     * @param folderId the id of the parent folder
     * @param filename the name we want the file to have on box.net
     * @param input InputStream with the contents of the file.
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.UploadResponse} with
     * 			data about the operation status and info about the newly uploaded file (if successful)
     */
    @Processor
    public UploadResponse uploadStream(String authToken, String folderId, String filename, InputStream input) {
    	byte[] data = null;
    	
    	try {
    		data = IOUtils.toByteArray(input);
    	} catch (IOException e) {
    		throw new IllegalArgumentException("Failed to read input stream", e);
    	}
    	
    	final Map<String, byte[]> uploadData = new HashMap<String, byte[]>();
    	uploadData.put(filename, data);
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("about to uploadFile using stream to folder " + folderId);
    	}
    	
    	final UploadRequest uploadRequest = BoxRequestFactory.createUploadRequest(authToken, false, folderId, uploadData);
    	return this.execute(new BoxClosure<UploadResponse>() {
    		
    		@Override
    		public UploadResponse execute() throws IOException, BoxException {
    			return client.upload(uploadRequest);
    		}
		}, "uploadStream");
    	
    	
    }
    
    /**
     * Makes a public share of a file or folder
     *
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample boxnet:public-share}
     *
     * @param authToken the authentication token obtained with the ticket
     * @param target The type of item to be shared.  This can be set as 'file' or 'folder'. Any other value will throw a {@link IllegalArgumentException}
     * @param targetId The id of the item you wish to share.  If the target is a folder, this will be the folder_id.  If the target is a file, this will be the file_id.
     * @param password The password to protect the folder or file.
     * @param message An message to be included in a notification email.
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.PublicShareResponse} with
     * 			data about the operation status and info about the shared folder (if successful)
     * @throws {@link IllegalArgumentException} if target is invalid
     */
    @Processor
    public PublicShareResponse publicShare(
									String authToken,
									String target,
									String targetId,
									String password,
									String message) {
    	validateTarget(target);
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("about to share folder with params:" +
    					"\ntarget: " + target +
    					"\ntargetId: " + targetId + 
    					"\npassword: " + password + 
    					"\nmessage: " + message);
    	}
    	
    	final PublicShareRequest publicShareRequest = BoxRequestFactory.createPublicShareRequest(
    			apiKey,	authToken, target, targetId, password, message, null);
    	
    	return this.execute(new BoxClosure<PublicShareResponse>() {
    		
    		@Override
    		public PublicShareResponse execute() throws IOException, BoxException {
    			return client.publicShare(publicShareRequest);
    		}
		}, "publicShare");
    }
    
    /**
     * This processor unshares a public shared file or folder
     * 
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample boxnet:public-unshare}
     * 
     * @param authToken the authentication token obtained with the ticket
     * @param target shoud be either 'file' or 'folder'
     * @param targetId is id of a file or folder to be unshared
     * @return  On a successful result, the status will be 'unshare_ok'. If the result wasn't successful, the status field can be: 'unshare_error', 'wrong_node', 'not_logged_in', 'application_restricted'.
     * @throws {@link IllegalArgumentException} if target is invalid
     */
    @Processor
    public String publicUnshare(String authToken, String target, String targetId) {
    	validateTarget(target);
    	final PublicUnshareRequest request = BoxRequestFactory.createPublicUnshareRequest(apiKey, authToken, target, targetId);
    	
    	PublicUnshareResponse response = this.execute(new BoxClosure<PublicUnshareResponse>() {
    		
    		@Override
    		public PublicUnshareResponse execute() throws IOException, BoxException {
    			return client.publicUnshare(request);
    		}
		}, "publicUnshare");
    	
    	return response.getStatus();
    }
    
    /**
     * This processor privately shares a file or folder with another user(s).
     * 'target' param, 'target_id' is . 'emails' params is an array of emails
     * of users' to share files with. if 'notify' param is , 'message' param .
     * 
     * Note: currently only files can be shared privately.
     * 
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample boxnet:private-share}
     * 
     * @param authToken the authentication token obtained with the ticket
     * @param target should be either 'file' or 'folder'
     * @param targetId the id of the file or folder to be shared
     * @param csvMails comma separated list of email addresses of the users that will receive the share
     * @param notify if true, then a notification email will be sent to users. Optional parameter, defaults to true
     * @param message is a message to be included in the notification email. Optional parameter, defaults to an empty string
     * @return if successful will be 'private_share_ok'. Otherwise can be: 'private_share_error', 'wrong_node', 'not_logged_in', 'application_restricted'.
     * @throws {@link IllegalArgumentException} if target is invalid or csvMails is null or empty
     */
    @Processor
    public String privateShare(String authToken,
    							String target,
    							String targetId,
    							String csvMails,
    							@Optional @Default("true") Boolean notify,
    							@Optional @Default("") String message )	{
    	
    	validateTarget(target);
    	
    	if (StringUtils.isEmpty(csvMails)) {
    		throw new IllegalArgumentException("csvMails cannot be empty");
    	}
    	
    	final PrivateShareRequest request = BoxRequestFactory.createPrivateShareRequest(
    					apiKey, authToken, target, targetId, csvMails.split(","), message, notify);
    	
    	PrivateShareResponse response = this.execute(new BoxClosure<PrivateShareResponse>() {
    		
    		@Override
    		public PrivateShareResponse execute() throws IOException, BoxException {
    			return client.privateShare(request);
    		}
		}, "privateShare");
    	
    	return response.getStatus();
    }
    
    /**
     * This processor is used to get a user's files and folders tree.
     * 
     * 'folderId' param defines root folder from which the tree begins.
     * 'csvParams' is comma separated list where you can set additional parameters,
     * which are: onelevel - make a tree of one level depth, so you will get
     * only files and folders stored in folder which folder_id you have
     * provided. nofiles - include folders only in result tree, no files. nozip
     * - do not zip tree xml.
     * 
     * On successful result you will receive 'listing_ok' as status and the tree xml.
     * if you haven't set 'nozip' as a parameter (it's set by default), then you have to unzip it. Then you will get xml like
     * this: (note that updatedand createdare UNIX timestamps in PST).
     *
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample boxnet:get-tree-structure}
     *
     * @param authToken the authentication token obtained with the ticket
     * @param folderId The ID of the root folder from which the tree begins.  If this value is "0", the user's full account tree is returned.
     * @param csvParams comma separated list of params. This is optional and defaults to 'nozip'
     * @param encoding optional parameter to specify the encoding to use when decoding BASE64. Defaults to UTF-8
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.GetAccountTreeResponse} with
     * 			data about the operation status and info about the inspected folder (if successful)
     */
    @Processor
    public GetAccountTreeResponse getTreeStructure(
    		String authToken,
			String folderId,
			@Optional @Default("nozip") String csvParams,
			final @Optional @Default("UTF-8") String encoding) {
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("fetching tree structure with params:\n" +
    					"\nfolderId: " + folderId + 
    					"\ncsvParams: " + csvParams);
    	}
    	
    	String[] params = StringUtils.isEmpty(csvParams) ? null : csvParams.split(",");
    	final GetAccountTreeRequest getAccountTreeRequest = BoxRequestFactory.createGetAccountTreeRequest(
    			apiKey, authToken, folderId, params);
    	
    	return this.execute(new BoxClosure<GetAccountTreeResponse>() {
    		
    		@Override
    		public GetAccountTreeResponse execute() throws IOException,	BoxException {
    			GetAccountTreeResponse response = client.getAccountTree(getAccountTreeRequest);
    			
    			if (response.getEncodedTree() != null) {
    				response.setEncodedTree(decodeBase64(response.getEncodedTree(), encoding));
    			}
    			
    			return response;
    		}
		}, "getTreeStructure");
    }
    
    
    /**
     * Downloads a file an returns its contents as a byte[] 
     *
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample boxnet:download}
     *
     * @param authToken the authentication token obtained with the ticket
     * @param fileId the id of the file we want to download
     * @return the file's contents as a byte array
     */
    @Processor
    public byte[] download(String authToken, String fileId) {
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("About to download file with id: " + fileId);
    	}
    	
    	final DownloadRequest downloadRequest = BoxRequestFactory.createDownloadRequest(authToken, fileId, false, null);
    	DownloadResponse response = this.execute(new BoxClosure<DownloadResponse>() {
    		
    		@Override
    		public DownloadResponse execute() throws IOException, BoxException {
    			return client.download(downloadRequest);
    		}
    		
		}, "download");
    	
    	return response.getRawData();
    }
    
    /**
     * Deletes a file or folder
     *
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample boxnet:delete}
     *
     * @param authToken the authentication token obtained with the ticket
     * @param target The type of item to be shared.  This can be set as 'file' or 'folder'. Any other value will throw a {@link IllegalArgumentException}
     * @param targetId The id of the item you wish to delete. If the target is a folder, this will be the folder_id.  If the target is a file, this will be the file_id.
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.DeleteResponse} with data about the operation status
     * @throws {@link IllegalArgumentException} if target is invalid
     */
    @Processor
    public DeleteResponse delete(final String authToken, final String target, final String targetId) {
    	validateTarget(target);
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("about to delete " + target + " " + targetId);
    	}
    	
    	final DeleteRequest deleteRequest = BoxRequestFactory.createDeleteRequest(apiKey, authToken, target, targetId);
    	return this.execute(new BoxClosure<DeleteResponse>() {
    		
    		@Override
    		public DeleteResponse execute() throws IOException, BoxException {
    			return client.delete(deleteRequest);
    		}
		}, "delete");
    }
    
    
    /**
     * Logs out the user associated with the authorization token
     *
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample boxnet:logout}
     *
     * @param authToken the authentication token obtained with the ticket
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.LogoutResponse} with data about the operation status
     */
    @Processor
    public LogoutResponse logout(String authToken) {
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("logging off authToken: " + authToken);
    	}
    	
    	final LogoutRequest logoutRequest = BoxRequestFactory.createLogoutRequest(apiKey, authToken);
    	
    	return this.execute(new BoxClosure<LogoutResponse>() {
    		
    		@Override
    		public LogoutResponse execute() throws IOException, BoxException {
    			return client.logout(logoutRequest);
    		}
		}, "logout");
    }
    
    /**
    * This method is used to verify user registration email
    * 
    * {@sample.xml ../../../doc/BoxNet-connector.xml.sample boxnet:verify-registration-email}
    * 
    * @param loginName The login username of the user for which you would like to verify registration.
    * @return Upon a successful registration, the return value will be 'email_ok'.
	*		If registration was not successful, it can be:
	*		'email_invalid' - The login provided is not a valid email address.
	*		'email_already_registered' - The login provided is already registered by another user.
	*		'application_restricted'- You provided an invalid api_key, or the api_key is restricted from calling this function. 
    */ 
    @Processor
    public String verifyRegistrationEmail(String loginName) {

        if (logger.isDebugEnabled()) {
        	logger.debug("checking registration email for loginName: " + loginName);
        }
        
        final VerifyRegistrationEmailRequest request = BoxRequestFactory.createVerifyRegistrationEmailRequest();
        request.setLoginName(loginName);
        request.setApiKey(apiKey);
        
        return this.execute(new BoxClosure<VerifyRegistrationEmailResponse>() {
        	
        	@Override
        	public VerifyRegistrationEmailResponse execute() throws IOException, BoxException {
        		return client.verifyRegistrationEmail(request);
        	}
		}, "verifyRegistrationEmail").getStatus();
    }
    
    /**
     * This processor returns all the user's tags.
     * 
     * On successful you will get an xml representing the tags that looks like this:
     * 
     * <?xml version="1.0"?> <tags> <tag id="37"> music </tag> <tag id="38"> mp3
     * </tag> </tags> If the result wasn't successful, status field can be:
     * not_logged_id, application_restricted.
     * 
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample boxnet:export-tags}
     * 
     * @param authToken the authentication token obtained with the ticket
     * @param encoding encoding to use when decoding from BASE64. Optional, defaults to UTF-8
     * @return a String xml representing the tags
     */
    @Processor
    public String exportTags(String authToken, @Optional @Default("UTF-8") String encoding) {
    	final ExportTagsRequest request = BoxRequestFactory.createExportTagsRequest(apiKey, authToken);
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("getting tags");
    	}
    	
    	ExportTagsResponse response = this.execute(new BoxClosure<ExportTagsResponse>() {
    		
    		@Override
    		public ExportTagsResponse execute() throws IOException, BoxException {
    			 return client.exportTags(request);
    			
    		}
    		
		}, "exportTags");
    	
    	if (response.getStatus().equals("export_tags_ok")) {
    		return decodeBase64(response.getEncodedTags(), encoding);
    	}
    	
    	throw new RuntimeException("Error retrieving tags. Box.net replied " + response.getStatus());
    }
    
    /**
     * This processor moves a file or folder to another folder.
     * 
     * 
     * On a successful result, status will be 's_move_node'. If the result
     * wasn't successful, status field can be: 'e_move_node', 'not_logged_in',
     * 'application_restricted'.
     * 
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample boxnet:move}
     * 
     * @param authToken the authentication token obtained with the ticket
     * @param target can be either 'file' or 'folder' depending on what do you
     * @param targetId is the id of a file or folder to be moved
     * @param destinationId is the destination folder id.
     * @return if successful 's_move_node'. Otherwise it can be 'e_move_node', 'not_logged_in',
     * 'application_restricted'.
     */
    @Processor
    public String move(String authToken, String target, String targetId, String destinationId) {
    	validateTarget(target);
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("moving " + target + " " + targetId + " to " + destinationId);
    	}
    	
    	final MoveRequest request = BoxRequestFactory.createMoveRequest(apiKey, authToken, target, targetId, destinationId);
    	
    	MoveResponse response = this.execute(new BoxClosure<MoveResponse>() {
    		
    		@Override
    		public MoveResponse execute() throws IOException, BoxException {
    			return client.move(request);
    		}
		}, "move");
    	
    	return response.getStatus();
    }
    
    /**
     * This processor renames a file or folder.
     * 
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample boxnet:move} 
     * 
     * @param authToken the authentication token obtained with the ticket
     * @param target can be either 'file' or 'folder' depending on what you want to rename
     * @param targetId is the id of a file or folder to be renamed
     * @param newName is the new name for a file or folder
     * @return if successful will be 's_rename_node'. Otherwise it can be: 'e_rename_node', 'not_logged_in', 'application_restricted'
     */
    @Processor
    public String rename(String authToken, String target, String targetId, String newName) {
    	validateTarget(target);
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("renaming " + target + " " + targetId + " to " + newName);
    	}
    	
    	final RenameRequest request = BoxRequestFactory.createRenameRequest(apiKey, authToken, target, targetId, newName);
    	
    	RenameResponse response = this.execute(new BoxClosure<RenameResponse>() {
    		
    		@Override
    		public RenameResponse execute() throws IOException, BoxException {
    			return client.rename(request);
    		}
		}, "rename");
    	
    	return response.getStatus();
    }
    
    /**
     * Gets information about a file
     * 
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample boxnet:get-file-info}
     * 
     * @param authToken the authentication token obtained with the ticket
     * @param fileId the id of the file you want info about
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.GetFileInfoResponse}
     */
    @Processor
    public GetFileInfoResponse getFileInfo(String authToken, String fileId) {
    	if (logger.isDebugEnabled()) {
    		logger.debug("getting information about file: " + fileId);
    	}
    	
    	final GetFileInfoRequest request = BoxRequestFactory.createGetFileInfoRequest(apiKey, authToken, fileId);
    	return this.execute(new BoxClosure<GetFileInfoResponse>() {
    		
    		@Override
    		public GetFileInfoResponse execute() throws IOException, BoxException {
    			return client.getFileInfo(request);
    		}
		}, "getFileInfo");
    }
    
    /**
     * This processor adds file or folder to tags list. 
     * 
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample boxnet:add-to-tag}
     * 
     * @param authToken the authentication token obtained with the ticket
     * @param csvTags comma separated list of tags
     * @param target can be either 'file' or 'folder' depending on what do you want to add
     * @param targetId the id of a file or folder to be added
     * @return 'addtotag_ok' if successful. Otherwise addtotag_error.
     * @throws {@link IllegalArgumentException} if target is invalid or csvTags is empty
     */
    @Processor
    public String addToTag(String authToken, String csvTags, String target, String targetId) {
    	validateTarget(target);
    	
    	if (StringUtils.isEmpty(csvTags)) {
    		throw new IllegalArgumentException("csvTags cannot be empty");
    	}
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("adding tags to " + target + " " + targetId + ": " + csvTags);
    	}
    	
    	final AddToTagRequest request = BoxRequestFactory.createAddToTagRequest(apiKey, authToken, csvTags.split(","), target, targetId);
    	AddToTagResponse response = this.execute(new BoxClosure<AddToTagResponse>() {
    		
    		@Override
    		public AddToTagResponse execute() throws IOException, BoxException {
    			return client.addToTag(request);
    		}
		}, "addToTag");
    	
    	return response.getStatus();
    }
    
    /**
     * 
     * This processor sets a description to a file or folder.
     * 
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample boxnet:set-description}
     * 
     * @param authToken the authentication token obtained with the ticket
     * @param target can be either 'file' or 'folder'
     * @param targetId the id of the folder/file you want to modify
     * @param description the description you want to set
     * @return 's_set_description' if successful. 'e_set_description' otherwise.
     */
    @Processor
    public String setDescription(String authToken, String target, String targetId, String description) {
    	validateTarget(target);
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("setting description of " + target + " " + targetId + " to:" + description);
    	}
    	
    	final SetDescriptionRequest request = BoxRequestFactory.createSetDescriptionRequest(apiKey, authToken, target, targetId, description);
    	SetDescriptionResponse response = this.execute(new BoxClosure<SetDescriptionResponse>() {
    		
    		@Override
    		public SetDescriptionResponse execute() throws IOException, BoxException {
    			return client.setDescription(request);
    		}
		}, "setDescription");
    	
    	return response.getStatus();
    }
    
    
    
    
    
    // internals
    
    public static void validateTarget(String target) {
    	if (!(TARGET_FILE.equals(target) || TARGET_FOLDER.equals(target))) {
    		throw new IllegalArgumentException("invalid target argument was provided. Valid values are " + TARGET_FILE + " and " + TARGET_FOLDER);
    	}
    }
    
    public static String decodeBase64(String encoded, String encoding) {
    	try {
    		return new String((byte[]) new Base64Decoder().doTransform(encoded, encoding));
    	} catch (TransformerException e) {
    		throw new RuntimeException("Error decoding Base64 value");
    	}
    }
    
    private interface BoxClosure<T extends BoxResponse> {
    	
    	public T execute() throws IOException, BoxException;
    }
    
    private <T extends BoxResponse> T execute(BoxClosure<T> closure, String operationName) {
    	
    	T response = null;
    	try {
    		response = closure.execute();
    		if (logger.isDebugEnabled()) {
    			logger.debug(operationName + " executed with return status: "
    					+ response.getStatus() + " and values:\n" + 
    					ToStringBuilder.reflectionToString(response));
    		}
    	} catch (IOException e) {
    		this.logAndThrow(e);
    	} catch (BoxException e) {
    		this.logAndThrow(e);
    	}
    	
    	return response;
    }
    
    private void logAndThrow(Exception e) {
    	final String msg = "exception caught on Box.net Cloud Connector";
    	if (logger.isDebugEnabled()) {
    		logger.error(msg, e);
    	}
    	
    	throw new RuntimeException(e);
    }
    
	public void setApiKey(String apiKey) {
		this.apiKey = apiKey;
	}
}
