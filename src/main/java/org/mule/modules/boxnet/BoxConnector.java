/**
 * Copyright (c) MuleSoft, Inc. All rights reserved. http://www.mulesoft.com
 *
 * The software in this package is published under the terms of the CPAL v1.0
 * license, a copy of which has been included with this distribution in the
 * LICENSE.md file.
 */

/**
 * This file was automatically generated by the Mule Development Kit
 */
package org.mule.modules.boxnet;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.inject.Inject;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.builder.ToStringBuilder;
import org.apache.log4j.Logger;
import org.mule.DefaultMuleMessage;
import org.mule.api.MuleContext;
import org.mule.api.MuleException;
import org.mule.api.MuleMessage;
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Connector;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.lifecycle.Start;
import org.mule.api.annotations.lifecycle.Stop;
import org.mule.api.annotations.param.Default;
import org.mule.api.annotations.param.Optional;
import org.mule.api.context.MuleContextAware;
import org.mule.api.transformer.TransformerException;
import org.mule.construct.Flow;
import org.mule.modules.boxnet.callback.AuthCallbackAdapter;
import org.mule.transformer.codec.Base64Decoder;

import cn.com.believer.songyuanframework.openapi.storage.box.BoxExternalAPI;
import cn.com.believer.songyuanframework.openapi.storage.box.constant.BoxConstant;
import cn.com.believer.songyuanframework.openapi.storage.box.factories.BoxRequestFactory;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.AddToTagRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.AddToTagResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.BoxResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.CreateFolderRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.CreateFolderResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.DeleteRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.DeleteResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.DownloadRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.DownloadResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.ExportTagsRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.ExportTagsResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.GetAccountTreeRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.GetAccountTreeResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.GetAuthTokenRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.GetAuthTokenResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.GetFileInfoRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.GetFileInfoResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.GetTicketRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.GetTicketResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.LogoutRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.LogoutResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.MoveRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.MoveResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.PrivateShareRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.PrivateShareResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.PublicShareRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.PublicShareResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.PublicUnshareRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.PublicUnshareResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.RegisterNewUserRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.RegisterNewUserResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.RenameRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.RenameResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.SetDescriptionRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.SetDescriptionResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.UploadRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.UploadResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.VerifyRegistrationEmailRequest;
import cn.com.believer.songyuanframework.openapi.storage.box.functions.VerifyRegistrationEmailResponse;
import cn.com.believer.songyuanframework.openapi.storage.box.impl.simple.SimpleBoxImpl;
import cn.com.believer.songyuanframework.openapi.storage.box.objects.BoxException;

/**
 * Box.net Cloud Connector Module.
 * 
 * @author MuleSoft, Inc.
 * @author mariano.gonzalez@mulesoft.com
 */
@Connector(name="box", schemaVersion="1.1.0", friendlyName="Box", minMuleVersion="3.3")
public class BoxConnector implements MuleContextAware {
    
	private static final Logger logger = Logger.getLogger(BoxConnector.class);
	private static final Base64Decoder decoder = new Base64Decoder();
	
	private static final String BOX_AUTH_TICKET = "boxAuthTicket";
	private static final String BOX_AUTH_TOKEN = "boxAuthToken";
	
	/**
	 * The url where the user needs to enter his credentials
	 */
	private static final String AUTH_URL = "https://www.box.net/api/1.0/auth/"; 
	
	private BoxExternalAPI client;
	
	private MuleContext muleContext;
	private AuthCallbackAdapter authCallback;
	
    /**
     * The API key obtained when registering a project with the Box platform.
     * For more information about this field please refer to {@link http://developers.box.net/}
     */
    @Configurable
    private String apiKey;
    
    /**
     * If true, an http inbound endpoint will be set in place to receive a callback
     * from box.net with the authToken once the user has authenticated.
     * 
     * If this callback is in place, there's no need for you to manually
     * invoke the get-auth-token processor.
     * 
     * For more info look at http://developers.box.net/w/page/12923915/ApiAuthentication
     * 
     * Defaults to false
     */
    @Optional
    @Configurable
    @Default("false")
    private boolean usesCallback = false;
    
    
    /**
     * The url where box.net will direct the authentication callback.
     * For more info look at http://developers.box.net/w/page/12923915/ApiAuthentication
     * 
     * Defaults to box_auth_callback
     */
    @Optional
    @Configurable
    @Default("box_auth_callback")
    private String callbackPath = "box_auth_callback";
   
    /**
     * The port where the authentication callback will be listening on
     * Defaults to 8080
     */
    @Optional
    @Configurable
    @Default("8080")
    private Integer callbackPort;
    
    /**
     * The name of a flow to be executed each time the authentication token
     * needs to be used. If this attribute is specified, then a flow with this named
     * will be fetch on the registry and invoked every time the auth token is needed.
     * This flow will receive a copy of the current mule message and must set the payload
     * to a valid auth token. If the flow fails to accomplish that, an exception will be thrown
     * 
     * For example:
     * 
     * &lt;box:config apiKey="${apiKey}" restoreAuthTokenFlow="restoreTokenFlow" saveAuthTokenFlow="saveTokenFlow"/&gt;
     * 
     *  &lt;flow name="restoreTokenFlow"&gt;
     *		&lt;objectstore:retrieve key="flowVars['currentUserId']"/&gt;
     *	&lt;/flow&gt;
     *
     *	&lt;flow name="save"&gt;
     *		&lt;objectstore:store key="flowVars['currentUserId']" value-ref="#[flowVars['boxAuthToken']]"/&gt;
     *	&lt;/flow&gt;
     *
     *	If this attribute is not specified, then the token will be fetched from memory. Notice that this means the token won't survive
     * an application restart and that the connector would be incapable of handling two different concurrent accounts
     */
    @Configurable
    @Optional
    private String restoreAuthTokenFlow;
    
    /**
     * The name of a flow to be executed each time an authentication token
     * is received. If this attribute is specified, then a flow with this name
     * will be fetch on the registry and invoked every time the auth token is obtained.
     * This flow will receive a copy of the current mule message carrying two additional invocation variables:
     * 
     * <ul>
     * 	<li>boxAuthTicket: The ticket for which the authorization token was generated</li>
     * 	<li>boxAuthToken: The obtained authorization token
     * </ul>
     * 
     * For example:
     * 
     * &lt;box:config apiKey="${apiKey}" restoreAuthTokenFlow="restoreTokenFlow" saveAuthTokenFlow="saveTokenFlow"/&gt;
     * 
     *  &lt;flow name="restoreTokenFlow"&gt;
     *		&lt;objectstore:retrieve key="flowVars['currentUserId']"/&gt;
     *	&lt;/flow&gt;
     *
     *	&lt;flow name="save"&gt;
     *		&lt;objectstore:store key="flowVars['currentUserId']" value-ref="#[flowVars['boxAuthToken']]"/&gt;
     *	&lt;/flow&gt;
     *
     * If this attribute is not specified, then the token will be stored in memory. Notice that this means the token won't survive
     * an application restart and that the connector would be incapable of handling two different concurrent accounts
     */
    @Configurable
    @Optional
    private String saveAuthTokenFlow;
    
    /**
     * Actual restore token flow egarly fetched
     */
    private Flow restoreTokenFlow;
    
    /**
     * Actual save token flow egarly fetched
     */
    private Flow saveTokenFlow;
    
    private String authToken;
    
    /**
     * This method initiaes the box client and the auth callback.
     * Also, it fetches the save/restore flows (if specified). If those are specified
     * but don't exist in the registry, then IllegalArgumentException is thrown
     * 
     * @throws MuleException
     * @throws IllegalArgumentException if restore/save token flows are specified but don't exist
     */
    @Start
    public void init() throws MuleException {
    	this.client = new SimpleBoxImpl();
    	this.authCallback = new AuthCallbackAdapter(this.muleContext, this);
		this.authCallback.setLocalPort(this.getCallbackPort());
		this.authCallback.setAsync(false);

		if (this.usesCallback) {
    		this.authCallback.start();
    	}
		
		if (!StringUtils.isBlank(this.restoreAuthTokenFlow)) {
			this.restoreTokenFlow = FlowUtils.getFlow(this.restoreAuthTokenFlow, muleContext);
			
			if (this.restoreTokenFlow == null) {
				throw new IllegalArgumentException(String.format("%s was specified as restoreAuthTokenFlow but it doesn't exists", this.restoreAuthTokenFlow));
			}
		}
		
		if (!StringUtils.isBlank(this.saveAuthTokenFlow)) {
			this.saveTokenFlow = FlowUtils.getFlow(this.saveAuthTokenFlow, muleContext);
			
			if (this.saveTokenFlow == null) {
				throw new IllegalArgumentException(String.format("%s was specified as saveAuthTokenFlow but it doesn't exists", this.saveAuthTokenFlow));
			}
		}
    }
    
    @Stop
    public void onStop() throws MuleException {
    	if (this.usesCallback) {
    		this.authCallback.stop();
    	}
    }
    
    /**
     * Get and access ticket using the configured apiKey. Optionally, you can ask the connector to automatically
     * redirect the browser to box authorization page so that the user can enter his credentials
     * 
     * Otherwise, the user needs to manually go to {@link https://www.box.net/api/1.0/auth/&lt;&lt;ticket&gt;&gt;}
     * 
     * Either way, the connector <b>WILL NOT</b> be responsible for storing this ticket.
     * 
     * For more info look at {@link http://developers.box.net/w/page/12923915/ApiAuthentication}
     * 
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample box:get-ticket}
     * 
     * @param message the current mule message
     * @param redirect if true, then the browser will be automatically redirected to https://www.box.net/api/1.0/auth/&lt;&lt;ticket&gt;&gt;
     *  
     * @return the obtained ticket
     */
    @Processor
    @Inject
    public String getTicket(MuleMessage message, @Optional @Default("true") Boolean redirect) {
    	
    	GetTicketResponse response = this.execute(new BoxClosure<GetTicketResponse>() {
    		
    		@Override
    		public GetTicketResponse execute() throws IOException, BoxException {
    			GetTicketRequest getTicketRequest = BoxRequestFactory.createGetTicketRequest(apiKey);
    			return client.getTicket(getTicketRequest);
    		}
		}, "getTicket");
    	
    	String ticket = response.getTicket();
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug(String.format("Fetched ticket with apiKey %s and obtained %s", this.apiKey, ticket));
    	}
    	
    	
    	if (redirect) {
    		
    		String redirectUrl = AUTH_URL + ticket;
    		
    		if (logger.isDebugEnabled()) {
    			logger.debug(String.format("redirecting to %s for authorizing ticket %s", redirectUrl, ticket));
    		}
    		
    		message.setOutboundProperty("http.status", "302");
    		message.setOutboundProperty("Location", redirectUrl);
    	}
    	
    	return ticket;
    }

    /**
     * After the user authenticates the ticket obtained with the get-ticket processor,
     * there're two ways to get the required auth token:
     * 
     * <ol>
	 *	<li>
	 *		You can configure box.net to make a callback returning the ticket and authToken, in which case you need to set the
	 * 		usesCallback and callbackPath config attributes accordingly 
	 *	</li>
	 *	<li>
	 *		You can use this processor to obtain the authentication token explicitly.
	 *  </li>
	 *	</ol>
	 *
	 *  Either way, this connector will retain the authToken in memory and will use it in all operations.
	 *  
	 *  For more info look at http://developers.box.net/w/page/12923915/ApiAuthentication
     *
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample box:auth-token}
     *
     * @param message the current mule message
     * @param ticket the ticket to authenticate against.
     * @throws IllegalArgumentException if the ticket does not match a logged user
     */
    @Processor
    @Inject
    public void authToken(MuleMessage message, String ticket) {
    	final GetAuthTokenRequest getAuthTokenRequest = BoxRequestFactory.createGetAuthTokenRequest(this.apiKey, ticket);
    	GetAuthTokenResponse getAuthTokenResponse = this.execute(new BoxClosure<GetAuthTokenResponse>() {
    		
    		@Override
    		public GetAuthTokenResponse execute() throws IOException, BoxException {
    			return client.getAuthToken(getAuthTokenRequest);
    		}
		}, "getAuthToken");
    	
        if (BoxConstant.STATUS_NOT_LOGGED_IN.equals(getAuthTokenResponse.getStatus())) {
        	 String msg = "Failed to obtain authToken using ticket " + ticket + ". Not logged in";
        	 logger.error(msg);
        	 throw new IllegalArgumentException(msg);
        }
         
        String authToken = getAuthTokenResponse.getAuthToken();
         
        if (logger.isDebugEnabled()) {
        	logger.debug("ticket " + ticket + "mapped to authToken: " + authToken);
        }
         
        this.saveAuthToken(message, ticket, authToken);
    }
    

    /**
     * Create a new user in box.net
     *
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample box:register-new-user}
     *
     * @param email the user's email
     * @param password the user's password
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.RegisterNewUserResponse} with
     * 			data about the operation status and info about the newly created user (if successful)
     */
    @Processor
    public RegisterNewUserResponse registerNewUser(String email, String password) {
    	if (logger.isDebugEnabled()) {
    		logger.debug("about to create user with email: " + email + " and pass: " + password);
    	}
    	
    	final RegisterNewUserRequest registerNewUserRequest = BoxRequestFactory.createRegisterNewUserRequest(apiKey, email, password);
    	return this.execute(new BoxClosure<RegisterNewUserResponse>() {
    		
    		@Override
    		public RegisterNewUserResponse execute() throws IOException, BoxException {
    			return client.registerNewUser(registerNewUserRequest);
    		}
		}, "registerNewUser");
    }
    
    /**
     * Create a new folder
     *
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample box:create-folder}
     *
     * @param message the current mule message
     * @param parentFolderId the id of the parent folder
     * @param folderName the name of the folder you want to create
     * @param share specifies if the folder is shared. This parameter is optional and defaults to false
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.CreateFolderResponse} with
     * 			data about the operation status and info about the newly created folder (if successful)
     */
    @Processor
    @Inject
    public CreateFolderResponse createFolder(MuleMessage message,
    										String parentFolderId,
    										String folderName,
    										@Optional @Default("false") Boolean share) {

    	String authToken = this.getAuthToken(message);
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("About to create folder:" +
    				"\nparentFolderId: " + parentFolderId +
    				"\nfolderName: " + folderName +
    				"\nshare: " + share);
    	}
    	
    	final CreateFolderRequest createFolderRequest =
    			BoxRequestFactory.createCreateFolderRequest(apiKey, authToken, parentFolderId, folderName, share);
    	
    	return this.execute(new BoxClosure<CreateFolderResponse>() {
    		
    		@Override
    		public CreateFolderResponse execute() throws IOException, BoxException {
    			
    			return client.createFolder(createFolderRequest);
    		}
		}, "create Folder");
    }
    
    /**
     * Receives a comma separated list of paths and uploads the corresponding
     * files.
     *
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample box:upload-files}
     *
     * @param message the current mule message
     * @param folderId the id of the parent folder. Defaults to 0 (the root folder)
     * @param paths a List of Strings with the paths where the files are. Defaults to payload
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.UploadResponse} with
     * 			data about the operation status and info about the newly uploaded files (if successful)
     */
    @Processor
    @Inject
    public UploadResponse uploadFiles(
    						MuleMessage message,
    						@Optional @Default("#[payload]") List<String> paths,
    						@Optional @Default("0") String folderId) {
    	
    	String authToken = this.getAuthToken(message);
    	
    	final Map<String, File> files = new HashMap<String, File>();
    	
    	for (String path : paths) {
    		File file = new File(path);
    		
    		if (!file.exists()) {
    			throw new IllegalArgumentException("File " + path + " does not exist");
    		}
    		
    		files.put(file.getName(), file);
    	}
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("about to uploadFiles with parameters:" +
    				"\ncsvPaths: " + paths +
    				"\nfolderId: " + folderId
    				);
    	}
    	
    	final UploadRequest uploadRequest = BoxRequestFactory.createUploadRequest(authToken, true, folderId, files);
    	
    	return this.execute(new BoxClosure<UploadResponse>() {
    		
    		@Override
    		public UploadResponse execute() throws IOException, BoxException {
    			return client.upload(uploadRequest);
    		}
		}, "uploadFiles");
    }
    
    /**
     * Receives an input stream and uploads its content as a file
     *
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample box:upload-stream}
     *
     * @param message the current mule message
     * @param folderId the id of the parent folder. Defaults to 0 which is the root folder
     * @param filename the name we want the file to have on box.net
     * @param input InputStream with the contents of the file. Defaults to the message payload.
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.UploadResponse} with
     * 			data about the operation status and info about the newly uploaded file (if successful)
     */
    @Processor
    @Inject
    public UploadResponse uploadStream(MuleMessage message,
							    		@Optional @Default("0") String folderId,
							    		String filename,
							    		@Optional @Default("#[payload]") InputStream input) {
    	
    	String authToken = this.getAuthToken(message);
    	byte[] data = null;
    	
    	try {
    		data = IOUtils.toByteArray(input);
    	} catch (IOException e) {
    		throw new IllegalArgumentException("Failed to read input stream", e);
    	}
    	
    	final Map<String, byte[]> uploadData = new HashMap<String, byte[]>();
    	uploadData.put(filename, data);
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("about to uploadFile using stream to folder " + folderId);
    	}
    	
    	final UploadRequest uploadRequest = BoxRequestFactory.createUploadRequest(authToken, false, folderId, uploadData);
    	return this.execute(new BoxClosure<UploadResponse>() {
    		
    		@Override
    		public UploadResponse execute() throws IOException, BoxException {
    			return client.upload(uploadRequest);
    		}
		}, "uploadStream");
    	
    	
    }
    
    /**
     * Makes a public share of a file or folder
     *
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample box:public-share}
     *
     * @param muleMessage the current mule message
     * @param target The type of item to be shared.  This can be set as 'file' or 'folder'. Any other value will throw a {@link IllegalArgumentException}
     * @param targetId The id of the item you wish to share.  If the target is a folder, this will be the folder_id.  If the target is a file, this will be the file_id.
     * @param password The password to protect the folder or file.
     * @param message An message to be included in a notification email.
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.PublicShareResponse} with
     * 			data about the operation status and info about the shared folder (if successful)
     * @throws {@link IllegalArgumentException} if target is invalid
     */
    @Processor
    @Inject
    public PublicShareResponse publicShare(
									MuleMessage muleMessage,
    								Target target,
									String targetId,
									String password,
									String message) {
    	
    	String authToken = this.getAuthToken(muleMessage);
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("about to share folder with params:" +
    					"\ntarget: " + target +
    					"\ntargetId: " + targetId + 
    					"\npassword: " + password + 
    					"\nmessage: " + message);
    	}
    	
    	final PublicShareRequest publicShareRequest = BoxRequestFactory.createPublicShareRequest(
    			apiKey,	authToken, target.name(), targetId, password, message, null);
    	
    	return this.execute(new BoxClosure<PublicShareResponse>() {
    		
    		@Override
    		public PublicShareResponse execute() throws IOException, BoxException {
    			return client.publicShare(publicShareRequest);
    		}
		}, "publicShare");
    }
    
    /**
     * This processor unshares a public shared file or folder
     * 
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample box:public-unshare}
     * 
     * @param message the current mule message
     * @param target shoud be either 'file' or 'folder'
     * @param targetId is id of a file or folder to be unshared
     * @return  On a successful result, the status will be 'unshare_ok'. If the result wasn't successful, the status field can be: 'unshare_error', 'wrong_node', 'not_logged_in', 'application_restricted'.
     * @throws {@link IllegalArgumentException} if target is invalid
     */
    @Processor
    @Inject
    public String publicUnshare(MuleMessage message, Target target, String targetId) {
    	String authToken = this.getAuthToken(message);
    	final PublicUnshareRequest request = BoxRequestFactory.createPublicUnshareRequest(apiKey, authToken, target.name(), targetId);
    	
    	PublicUnshareResponse response = this.execute(new BoxClosure<PublicUnshareResponse>() {
    		
    		@Override
    		public PublicUnshareResponse execute() throws IOException, BoxException {
    			return client.publicUnshare(request);
    		}
		}, "publicUnshare");
    	
    	return response.getStatus();
    }
    
    /**
     * This processor privately shares a file or folder with another user(s).
     * 'target' param, 'target_id' is . 'emails' params is an array of emails
     * of users' to share files with. if 'notify' param is , 'message' param .
     * 
     * Note: currently only files can be shared privately.
     * 
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample box:private-share}
     * 
     * @param muleMessage the current mule message
     * @param target should be either 'file' or 'folder'
     * @param targetId the id of the file or folder to be shared
     * @param csvMails comma separated list of email addresses of the users that will receive the share
     * @param notify if true, then a notification email will be sent to users. Optional parameter, defaults to true
     * @param message is a message to be included in the notification email. Optional parameter, defaults to an empty string
     * @return if successful will be 'private_share_ok'. Otherwise can be: 'private_share_error', 'wrong_node', 'not_logged_in', 'application_restricted'.
     * @throws {@link IllegalArgumentException} if target is invalid or csvMails is null or empty
     */
    @Processor
    @Inject
    public String privateShare( MuleMessage muleMessage,
    							Target target,
    							String targetId,
    							String csvMails,
    							@Optional @Default("true") Boolean notify,
    							@Optional @Default("") String message )	{
    	
    	String authToken = this.getAuthToken(muleMessage);
    	
    	if (StringUtils.isEmpty(csvMails)) {
    		throw new IllegalArgumentException("csvMails cannot be empty");
    	}
    	
    	final PrivateShareRequest request = BoxRequestFactory.createPrivateShareRequest(
    					apiKey, authToken, target.name(), targetId, csvMails.split(","), message, notify);
    	
    	PrivateShareResponse response = this.execute(new BoxClosure<PrivateShareResponse>() {
    		
    		@Override
    		public PrivateShareResponse execute() throws IOException, BoxException {
    			return client.privateShare(request);
    		}
		}, "privateShare");
    	
    	return response.getStatus();
    }
    
    /**
     * This processor is used to get a user's files and folders tree.
     * 
     * 'folderId' param defines root folder from which the tree begins.
     * 'csvParams' is comma separated list where you can set additional parameters,
     * which are: onelevel - make a tree of one level depth, so you will get
     * only files and folders stored in folder which folder_id you have
     * provided. nofiles - include folders only in result tree, no files. nozip
     * - do not zip tree xml.
     * 
     * On successful result you will receive 'listing_ok' as status and the tree xml.
     * if you haven't set 'nozip' as a parameter (it's set by default), then you have to unzip it. Then you will get xml like
     * this: (note that updatedand createdare UNIX timestamps in PST).
     *
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample box:get-tree-structure}
     *
     * @param message the current mule message
     * @param folderId The ID of the root folder from which the tree begins.  If this value is "0", the user's full account tree is returned. Defaults to zero
     * @param csvParams comma separated list of params. This is optional and defaults to 'nozip'
     * @param encoding optional parameter to specify the encoding to use when decoding BASE64. Defaults to UTF-8
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.GetAccountTreeResponse} with
     * 			data about the operation status and info about the inspected folder (if successful)
     */
    @Processor
    @Inject
    public GetAccountTreeResponse getTreeStructure(
    		MuleMessage message,
    		@Optional @Default("0") String folderId,
			@Optional @Default("nozip") String csvParams,
			final @Optional @Default("UTF-8") String encoding) {
    	
    	String authToken = this.getAuthToken(message);
    	if (logger.isDebugEnabled()) {
    		logger.debug("fetching tree structure with params:\n" +
    					"\nfolderId: " + folderId + 
    					"\ncsvParams: " + csvParams);
    	}
    	
    	String[] params = StringUtils.isEmpty(csvParams) ? null : csvParams.split(",");
    	final GetAccountTreeRequest getAccountTreeRequest = BoxRequestFactory.createGetAccountTreeRequest(
    			apiKey, authToken, folderId, params);
    	
    	return this.execute(new BoxClosure<GetAccountTreeResponse>() {
    		
    		@Override
    		public GetAccountTreeResponse execute() throws IOException,	BoxException {
    			GetAccountTreeResponse response = client.getAccountTree(getAccountTreeRequest);
    			
    			if (response.getEncodedTree() != null) {
    				response.setEncodedTree(decode(response.getEncodedTree(), encoding));
    			}
    			
    			return response;
    		}
		}, "getTreeStructure");
    }
    
    
    /**
     * Downloads a file an returns its contents as a byte[] 
     *
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample box:download}
     *
     * @param message the current mule message
     * @param fileId the id of the file we want to download
     * @return the file's contents as a byte array
     */
    @Processor
    @Inject
    public byte[] download(MuleMessage message, String fileId) {
    	
    	String authToken = this.getAuthToken(message);
    	if (logger.isDebugEnabled()) {
    		logger.debug("About to download file with id: " + fileId);
    	}
    	
    	final DownloadRequest downloadRequest = BoxRequestFactory.createDownloadRequest(authToken, fileId, false, null);
    	DownloadResponse response = this.execute(new BoxClosure<DownloadResponse>() {
    		
    		@Override
    		public DownloadResponse execute() throws IOException, BoxException {
    			return client.download(downloadRequest);
    		}
    		
		}, "download");
    	
    	return response.getRawData();
    }
    
    /**
     * Deletes a file or folder
     *
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample box:delete}
     *
     * @param message the current mule message
     * @param target The type of item to be shared.  This can be set as 'file' or 'folder'. Any other value will throw a {@link IllegalArgumentException}
     * @param targetId The id of the item you wish to delete. If the target is a folder, this will be the folder_id.  If the target is a file, this will be the file_id.
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.DeleteResponse} with data about the operation status
     * @throws {@link IllegalArgumentException} if target is invalid
     */
    @Processor
    @Inject
    public DeleteResponse delete(MuleMessage message, final Target target, final String targetId) {
    	String authToken = this.getAuthToken(message);
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("about to delete " + target + " " + targetId);
    	}
    	
    	final DeleteRequest deleteRequest = BoxRequestFactory.createDeleteRequest(apiKey, authToken, target.name(), targetId);
    	return this.execute(new BoxClosure<DeleteResponse>() {
    		
    		@Override
    		public DeleteResponse execute() throws IOException, BoxException {
    			return client.delete(deleteRequest);
    		}
		}, "delete");
    }
    
    
    /**
     * Logs out the user associated with the authorization token
     *
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample box:logout}
     *
     * @param message the current mule message
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.LogoutResponse} with data about the operation status
     */
    @Processor
    @Inject
    public LogoutResponse logout(MuleMessage message) {
    	String authToken = this.getAuthToken(message);  	
    	if (logger.isDebugEnabled()) {
    		logger.debug("logging off authToken: " + authToken);
    	}
    	
    	final LogoutRequest logoutRequest = BoxRequestFactory.createLogoutRequest(apiKey, authToken);
    	
    	return this.execute(new BoxClosure<LogoutResponse>() {
    		
    		@Override
    		public LogoutResponse execute() throws IOException, BoxException {
    			return client.logout(logoutRequest);
    		}
		}, "logout");
    }
    
    /**
    * This method is used to verify user registration email
    * 
    * {@sample.xml ../../../doc/BoxNet-connector.xml.sample box:verify-registration-email}
    * 
    * @param message the current mule message
    * @param loginName The login username of the user for which you would like to verify registration.
    * @return Upon a successful registration, the return value will be 'email_ok'.
	*		If registration was not successful, it can be:
	*		'email_invalid' - The login provided is not a valid email address.
	*		'email_already_registered' - The login provided is already registered by another user.
	*		'application_restricted'- You provided an invalid api_key, or the api_key is restricted from calling this function. 
    */ 
    @Processor
    @Inject
    public String verifyRegistrationEmail(MuleMessage message, String loginName) {

        if (logger.isDebugEnabled()) {
        	logger.debug("checking registration email for loginName: " + loginName);
        }
        
        final VerifyRegistrationEmailRequest request = BoxRequestFactory.createVerifyRegistrationEmailRequest();
        request.setLoginName(loginName);
        request.setApiKey(apiKey);
        
        return this.execute(new BoxClosure<VerifyRegistrationEmailResponse>() {
        	
        	@Override
        	public VerifyRegistrationEmailResponse execute() throws IOException, BoxException {
        		return client.verifyRegistrationEmail(request);
        	}
		}, "verifyRegistrationEmail").getStatus();
    }
    
    /**
     * This processor returns all the user's tags.
     * 
     * On successful you will get an xml representing the tags that looks like this:
     * 
     * <?xml version="1.0"?> <tags> <tag id="37"> music </tag> <tag id="38"> mp3
     * </tag> </tags> If the result wasn't successful, status field can be:
     * not_logged_id, application_restricted.
     * 
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample box:export-tags}
     * 
     * @param message the current mule message
     * @param encoding encoding to use when decoding from BASE64. Optional, defaults to UTF-8
     * @return a String xml representing the tags
     */
    @Processor
    @Inject
    public String exportTags(MuleMessage message, @Optional @Default("UTF-8") String encoding) {
    	String authToken = this.getAuthToken(message);
    	final ExportTagsRequest request = BoxRequestFactory.createExportTagsRequest(apiKey, authToken);
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("getting tags");
    	}
    	
    	ExportTagsResponse response = this.execute(new BoxClosure<ExportTagsResponse>() {
    		
    		@Override
    		public ExportTagsResponse execute() throws IOException, BoxException {
    			 return client.exportTags(request);
    			
    		}
    		
		}, "exportTags");
    	
    	if (response.getStatus().equals("export_tags_ok")) {
    		return this.decode(response.getEncodedTags(), encoding);
    	}
    	
    	throw new RuntimeException("Error retrieving tags. Box.net replied " + response.getStatus());
    }
    
    /**
     * This processor moves a file or folder to another folder.
     * 
     * 
     * On a successful result, status will be 's_move_node'. If the result
     * wasn't successful, status field can be: 'e_move_node', 'not_logged_in',
     * 'application_restricted'.
     * 
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample box:move}
     * 
     * @param message the current mule message
     * @param target can be either 'file' or 'folder' depending on what do you
     * @param targetId is the id of a file or folder to be moved
     * @param destinationId is the destination folder id.
     * @return if successful 's_move_node'. Otherwise it can be 'e_move_node', 'not_logged_in',
     * 'application_restricted'.
     */
    @Processor
    @Inject
    public String move(MuleMessage message, Target target, String targetId, String destinationId) {
    	String authToken = this.getAuthToken(message);
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("moving " + target + " " + targetId + " to " + destinationId);
    	}
    	
    	final MoveRequest request = BoxRequestFactory.createMoveRequest(apiKey, authToken, target.name(), targetId, destinationId);
    	
    	MoveResponse response = this.execute(new BoxClosure<MoveResponse>() {
    		
    		@Override
    		public MoveResponse execute() throws IOException, BoxException {
    			return client.move(request);
    		}
		}, "move");
    	
    	return response.getStatus();
    }
    
    /**
     * This processor renames a file or folder.
     * 
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample box:move} 
     * 
     * @param message the current mule message
     * @param target can be either 'file' or 'folder' depending on what you want to rename
     * @param targetId is the id of a file or folder to be renamed
     * @param newName is the new name for a file or folder
     * @return if successful will be 's_rename_node'. Otherwise it can be: 'e_rename_node', 'not_logged_in', 'application_restricted'
     */
    @Processor
    @Inject
    public String rename(MuleMessage message, Target target, String targetId, String newName) {
    	String authToken = this.getAuthToken(message);
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("renaming " + target + " " + targetId + " to " + newName);
    	}
    	
    	final RenameRequest request = BoxRequestFactory.createRenameRequest(apiKey, authToken, target.name(), targetId, newName);
    	
    	RenameResponse response = this.execute(new BoxClosure<RenameResponse>() {
    		
    		@Override
    		public RenameResponse execute() throws IOException, BoxException {
    			return client.rename(request);
    		}
		}, "rename");
    	
    	return response.getStatus();
    }
    
    /**
     * Gets information about a file
     * 
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample box:get-file-info}
     * 
     * @param message the current mule message
     * @param fileId the id of the file you want info about
     * @return an instance of {@link cn.com.believer.songyuanframework.openapi.storage.box.functions.GetFileInfoResponse}
     */
    @Processor
    @Inject
    public GetFileInfoResponse getFileInfo(MuleMessage message, String fileId) {
    	String authToken = this.getAuthToken(message);
    	if (logger.isDebugEnabled()) {
    		logger.debug("getting information about file: " + fileId);
    	}
    	
    	final GetFileInfoRequest request = BoxRequestFactory.createGetFileInfoRequest(apiKey, authToken, fileId);
    	return this.execute(new BoxClosure<GetFileInfoResponse>() {
    		
    		@Override
    		public GetFileInfoResponse execute() throws IOException, BoxException {
    			return client.getFileInfo(request);
    		}
		}, "getFileInfo");
    }
    
    /**
     * This processor adds file or folder to tags list. 
     * 
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample box:add-to-tag}
     * 
     * @param message the current mule message
     * @param csvTags comma separated list of tags
     * @param target can be either 'file' or 'folder' depending on what do you want to add
     * @param targetId the id of a file or folder to be added
     * @return 'addtotag_ok' if successful. Otherwise addtotag_error.
     * @throws {@link IllegalArgumentException} if target is invalid or csvTags is empty
     */
    @Processor
    @Inject
    public String addToTag(MuleMessage message, String csvTags, Target target, String targetId) {
    	String authToken = this.getAuthToken(message);
    	
    	if (StringUtils.isEmpty(csvTags)) {
    		throw new IllegalArgumentException("csvTags cannot be empty");
    	}
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("adding tags to " + target + " " + targetId + ": " + csvTags);
    	}
    	
    	final AddToTagRequest request = BoxRequestFactory.createAddToTagRequest(apiKey, authToken, csvTags.split(","), target.name(), targetId);
    	AddToTagResponse response = this.execute(new BoxClosure<AddToTagResponse>() {
    		
    		@Override
    		public AddToTagResponse execute() throws IOException, BoxException {
    			return client.addToTag(request);
    		}
		}, "addToTag");
    	
    	return response.getStatus();
    }
    
    /**
     * 
     * This processor sets a description to a file or folder.
     * 
     * {@sample.xml ../../../doc/BoxNet-connector.xml.sample box:set-description}
     * 
     * @param message the current mule message
     * @param target can be either 'file' or 'folder'
     * @param targetId the id of the folder/file you want to modify
     * @param description the description you want to set
     * @return 's_set_description' if successful. 'e_set_description' otherwise.
     */
    @Processor
    @Inject
    public String setDescription(MuleMessage message, Target target, String targetId, String description) {
    	String authToken = this.getAuthToken(message);
    	
    	if (logger.isDebugEnabled()) {
    		logger.debug("setting description of " + target + " " + targetId + " to:" + description);
    	}
    	
    	final SetDescriptionRequest request = BoxRequestFactory.createSetDescriptionRequest(apiKey, authToken, target.name(), targetId, description);
    	SetDescriptionResponse response = this.execute(new BoxClosure<SetDescriptionResponse>() {
    		
    		@Override
    		public SetDescriptionResponse execute() throws IOException, BoxException {
    			return client.setDescription(request);
    		}
		}, "setDescription");
    	
    	return response.getStatus();
    }
    
    private String getAuthToken(MuleMessage message) {
    	String token = this.restoreAuthToken(message);
    	if (token == null) {
    		throw new IllegalStateException("Auth token not obtained yet");
    	}
    	
    	return token;
    }
    
   public void saveAuthToken(MuleMessage message, String ticket, String authToken) {
	   if (this.saveTokenFlow == null) {
			this.authToken = authToken;
		} else {
			MuleMessage copy = new DefaultMuleMessage(message);
			copy.setInvocationProperty(BOX_AUTH_TICKET, ticket);
			copy.setInvocationProperty(BOX_AUTH_TOKEN, authToken);
			
			FlowUtils.callFlow(this.saveTokenFlow, copy);
		}
    }
    
    public String restoreAuthToken(MuleMessage message) {
    	if (this.restoreTokenFlow == null) {
    		return this.authToken;
    	} else {
    		MuleMessage restoreMessage = FlowUtils.callFlow(this.restoreTokenFlow, new DefaultMuleMessage(message)); 
    		Object payload = restoreMessage.getPayload();
    		
    		if (payload instanceof String) {
    			String token = (String) payload;
    			if (StringUtils.isBlank(token)) {
    				throw new IllegalArgumentException("Restore token flow returned an empty string. It seems like you don't have an auth token yet");
    			}
    			
    			return token;
    		}
    		
    		throw new IllegalArgumentException(
    						String.format("A String payload was expected after invoking restore token flow '%s', but %s was found instead",
	    									this.restoreAuthTokenFlow,
	    									payload == null ? "null" : payload.getClass().getCanonicalName()
    									)
    						);
    	}
    }
    
    private interface BoxClosure<T extends BoxResponse> {
    	
    	public T execute() throws IOException, BoxException;
    }
    
    private <T extends BoxResponse> T execute(BoxClosure<T> closure, String operationName) {
    	
    	T response = null;
    	try {
    		response = closure.execute();
    		if (logger.isDebugEnabled()) {
    			logger.debug(operationName + " executed with return status: "
    					+ response.getStatus() + " and values:\n" + 
    					ToStringBuilder.reflectionToString(response));
    		}
    	} catch (IOException e) {
    		this.logAndThrow(e);
    	} catch (BoxException e) {
    		this.logAndThrow(e);
    	}
    	
    	return response;
    }
    
    private String decode(String encoded, String encoding) {
    	try {
    		return new String((byte[]) decoder.doTransform(encoded, encoding));
    	} catch (TransformerException e) {
    		throw new RuntimeException("Error decoding Base64 value");
    	}
    }
    
    private void logAndThrow(Exception e) {
    	final String msg = "exception caught on Box.net Cloud Connector";
    	if (logger.isDebugEnabled()) {
    		logger.error(msg, e);
    	}
    	
    	throw new RuntimeException(e);
    }
    
	public String getCallbackPath() {
		return callbackPath;
	}

	public void setCallbackPath(String callbackPath) {
		this.callbackPath = callbackPath;
	}

	public void setApiKey(String apiKey) {
		this.apiKey = apiKey;
	}
	
	public Integer getCallbackPort() {
		return callbackPort;
	}

	public void setCallbackPort(Integer callbackPort) {
		this.callbackPort = callbackPort;
	}
	
	public boolean isUsesCallback() {
		return usesCallback;
	}

	public void setUsesCallback(boolean usesCallback) {
		this.usesCallback = usesCallback;
	}

	@Override
	public void setMuleContext(MuleContext context) {
		this.muleContext = context;
	}

	public String getRestoreAuthTokenFlow() {
		return restoreAuthTokenFlow;
	}

	public void setRestoreAuthTokenFlow(String restoreAuthTokenFlow) {
		this.restoreAuthTokenFlow = restoreAuthTokenFlow;
	}

	public String getSaveAuthTokenFlow() {
		return saveAuthTokenFlow;
	}

	public void setSaveAuthTokenFlow(String saveAuthTokenFlow) {
		this.saveAuthTokenFlow = saveAuthTokenFlow;
	}

	public String getApiKey() {
		return apiKey;
	}
	
	
}
